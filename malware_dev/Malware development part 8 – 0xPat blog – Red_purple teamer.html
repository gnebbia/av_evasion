<!DOCTYPE html>
<html><head>
    <title>Malware development part 8 – 0xPat blog – Red/purple teamer</title>

        <meta charset="utf-8">
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

    
    <meta name="description" content="Introduction
This is the eigth post of a series which regards the development of malicious software. In this series we will explore and try to implement multiple techniques used by malicious applications to execute code, hide from defenses and persist.
This time we will implement a COFF object file loader, which is similar to BOF (beacon object file) feature of Cobalt Strike. This has been also tackled by TrustedSec.

">
    <meta property="og:description" content="Introduction
This is the eigth post of a series which regards the development of malicious software. In this series we will explore and try to implement multiple techniques used by malicious applications to execute code, hide from defenses and persist.
This time we will implement a COFF object file loader, which is similar to BOF (beacon object file) feature of Cobalt Strike. This has been also tackled by TrustedSec.

">
    
    <meta name="author" content="0xPat blog">

    
    <meta property="og:title" content="Malware development part 8">
    <meta property="twitter:title" content="Malware development part 8">
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="Malware%20development%20part%208%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/style.css">
    <link rel="alternate" type="application/rss+xml" title="0xPat blog - Red/purple teamer" href="https://0xpat.github.io/feed.xml">

  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          
          <div class="site-info">
            <h1 class="site-name"><a href="https://0xpat.github.io/">0xPat blog</a></h1>
            <p class="site-description">Red/purple teamer</p>
          </div>

          <nav>
            <a href="https://0xpat.github.io/">Blog</a>
            <a href="https://0xpat.github.io/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>Malware development part 8</h1>

  <div class="entry">
    <h2 id="introduction">Introduction</h2>
<p>This is the eigth post of a series which regards the development of 
malicious software. In this series we will explore and try to implement 
multiple techniques used by malicious applications to execute code, hide
 from defenses and persist.<br>
This time we will implement a COFF object file loader, which is similar to <a href="https://www.cobaltstrike.com/help-beacon-object-files">BOF (beacon object file) feature of Cobalt Strike</a>. This has been also tackled by <a href="https://www.trustedsec.com/blog/coffloader-building-your-own-in-memory-loader-or-how-to-run-bofs/">TrustedSec</a>.</p>

<p>The code is in <a href="https://github.com/0xpat/COFFInjector">my GitHub repo</a>.</p>

<p>Note: We are working with 64-bit code here.</p>
<h2 id="c-code-compilation">C code compilation</h2>
<p>Generating an executable from C/C++ source code is a three-step process:</p>
<ol>
  <li>Preprocessing - interpretation of precompiler directives (merging <code class="language-plaintext highlighter-rouge">#include</code>d files, replacing <code class="language-plaintext highlighter-rouge">#define</code>d identifiers). Precompiler basically replaces text in the source code to produce a translation unit.</li>
  <li>Compilation (at which we took a detailed look in part 6). Compiler
 generates assembly from source code and creates an object file.</li>
  <li>Linking - combining object files and needed libraries into the final executable (which can also be a DLL).</li>
</ol>

<p>An executable can be either natively executed by OS loader or 
injected into memory (for example via process hollowing or any other 
applicable technique).</p>

<p>But what if we could execute object files? Actually this is possible,
 since these files contain the actual machine code we’re interesed in.</p>

<h2 id="coff-object-files">COFF object files</h2>
<p>Common Object File Format is a executable code format originating 
from Unix. Microsoft created their own variant of COFF and PE format 
based on that. [Microsoft documentation] contains a miture of 
information regarding COFF and PE file formats.</p>

<p>Object files produced by Visual Studio compiler use COFF format. Such an object file (with <code class="language-plaintext highlighter-rouge">.obj</code> extension) contains:</p>
<ul>
  <li>header (with architecture information, timestamp, number of sections and symbols and others),</li>
  <li>sections (with assembly, debug information, linker directives, exceptions information, static data etc.),</li>
  <li>symbols (like functions and variables) table with information about their location.</li>
</ul>

<p>Sections may contain relocation information which specifies how 
section data should be modified by linker and then during loading into 
memory. For example <code class="language-plaintext highlighter-rouge">.text</code>
 section with assembly has information specifying what parts of code 
should be replaced and what should they reference in memory. More on 
that later.</p>

<p>We need to browse the COFF file contents and extract assembly along 
with relocation data and perform relocations. The final code (with 
relocations applied) can be executed by just calling it as a function (<code class="language-plaintext highlighter-rouge">((void(*)())(code))()</code>) or with  (for example with <code class="language-plaintext highlighter-rouge">CreateThread</code>).</p>

<h3 id="example-object-file">Example object file</h3>
<p>Let’s consider a very simple console application:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">MessageBoxA</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">"Content"</span><span class="p">,</span> <span class="s">"Title"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">MessageBoxA</code> function is located in <code class="language-plaintext highlighter-rouge">user32.dll</code> - we need to hint the linker about that.</p>

<blockquote>
  <p>Normally, <code class="language-plaintext highlighter-rouge">.lib</code>
 files are static libraries containing code (actually object files) that
 can be statically linked to an executable. However with dynamic linking
 linker uses special <code class="language-plaintext highlighter-rouge">.lib</code>
 files which point to relevant dynamic libraries - this information is 
used by linker to build the Import Address Table of an executable.</p>
</blockquote>

<p>This can be done either by changing the project options in Visual Studio or using the following directive:</p>

<p><code class="language-plaintext highlighter-rouge">#pragma comment(lib, "user32.lib")</code></p>

<blockquote>
  <p>I disabled compiler optimization (<code class="language-plaintext highlighter-rouge">/Od</code>)
 for this piece of code. Enabling optimization resulted in different 
data arrangement in the object file and caused problems with my PoC COFF
 loader. Further testing would be required.</p>
</blockquote>

<p>Compilation using MSVC compiler (<code class="language-plaintext highlighter-rouge">cl.exe</code>) produces an object file (with <code class="language-plaintext highlighter-rouge">.obj</code> extension). We can analyze its content using <code class="language-plaintext highlighter-rouge">dumpbin</code> tool shipped with MSVC. Let’s see some of the tool’s output.</p>

<h4 id="directives-drectve-section">Directives (<code class="language-plaintext highlighter-rouge">.drectve</code> section)</h4>
<p>Here are linker directives, most importantly information on which libraries should be browsed for external functions.</p>

<p><img src="Malware%20development%20part%208%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/drectve.png" alt="drectve.png"></p>

<h4 id="read-only-data-rdata-section">Read-only data (<code class="language-plaintext highlighter-rouge">.rdata</code> section)</h4>
<p>This is statically initialized data, for example string literals.</p>

<p><img src="Malware%20development%20part%208%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/rdata.png" alt="rdata.png"></p>

<h4 id="executable-code-text-section">Executable code (<code class="language-plaintext highlighter-rouge">.text</code> section)</h4>
<p>This is the actual assembly. In my example this section has been named <code class="language-plaintext highlighter-rouge">.text$mn</code> by the MSVC compiler.</p>

<p><img src="Malware%20development%20part%208%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/text.png" alt="text.png"></p>

<p>This is where things get more interesting, let’s disassemble the code:</p>

<p><img src="Malware%20development%20part%208%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/code.png" alt="code.png"></p>

<p>We see here how <code class="language-plaintext highlighter-rouge">MessageBoxA</code> arguments (int 0, char* “Content”, char* “Title”, int 0) are passed according to the <a href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention">x64 calling convention</a>.</p>

<p>Let’s take a look at the third instruction (located at offset <code class="language-plaintext highlighter-rouge">0x07</code>. When disassembled using for example <a href="https://github.com/reyammer/shellnoob">ShellNoob</a> the instruction uses <code class="language-plaintext highlighter-rouge">0x00000000</code> offset:</p>

<p><img src="Malware%20development%20part%208%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/code2.png" alt="code2.png"></p>

<p>So how does the <code class="language-plaintext highlighter-rouge">dumpbin</code> disassembler knows that function should reference a symbol? That’s where relocations come into play. Below the <code class="language-plaintext highlighter-rouge">.text</code> section raw data we can see relocation information. For example, first relocation table entry says that <code class="language-plaintext highlighter-rouge">0x00000000</code> bytes at offset <code class="language-plaintext highlighter-rouge">0x0A</code> (which is the second operand of <code class="language-plaintext highlighter-rouge">lea</code> instruction) should be replaced with actual (relative to <code class="language-plaintext highlighter-rouge">RIP</code>) address of symbol no. 8.</p>

<p>The same goes for the <code class="language-plaintext highlighter-rouge">call</code> instruction at offset <code class="language-plaintext highlighter-rouge">0x17</code>
 along with respective relocation entry and symbol. However here 
relocation concerns relative function address address. That’s right - 
relative address (<code class="language-plaintext highlighter-rouge">call</code> operand) gets dereferenced and the value stored there (actual <code class="language-plaintext highlighter-rouge">MessageBoxA</code> address) is called.</p>

<p>When the code gets loaded into system memory, loader parses 
relocation data and puts functions and data addresses in right places. 
However this happens during PE executable loading. We want to load the 
COFF object file, so we need to analyze it and perform in-memory 
relocations.</p>
<h4 id="symbol-table">Symbol table</h4>
<p>This table contains symbols such as static variables or external functions.</p>

<p><img src="Malware%20development%20part%208%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/symbols.png" alt="symbols.png"></p>

<p>The symbol table is <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#coff-symbol-table">a bit tricky to read and understand</a>. However usually the <code class="language-plaintext highlighter-rouge">Value</code> field indicates the offset of the symbol within the section (described by <code class="language-plaintext highlighter-rouge">SectionNumber</code> field).</p>

<p>Also, to know where one symbol data ends, we need to check the offset of the next one in the same section or total section size.</p>

<h2 id="the-object-file-loader">The object file loader</h2>
<p>To inject and execute a simple COFF file we need to read the <code class="language-plaintext highlighter-rouge">.text</code>
 section and fill all zeros with relative addresses of external 
functions and static data (i.e. relocate symbols referenced in this 
section). Of course we also need to place these symbols somewhere in 
memory, for example after the assembly.</p>

<p>To find external functions we will need to browse libraries indicated in linker directives. We can use <code class="language-plaintext highlighter-rouge">LoadLibrary</code>/<code class="language-plaintext highlighter-rouge">GetModuleHandle</code>/<code class="language-plaintext highlighter-rouge">GetProcAddress</code> functions or for example browse PEB and <code class="language-plaintext highlighter-rouge">InMemoryOrderModuleList</code> (see part 4).</p>

<p>The diagram below illustrates this concept:</p>

<p><img src="Malware%20development%20part%208%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/concept.png" alt="concept.png"></p>

<p>I used <a href="https://github.com/serge1/COFFI">COFFI</a> library 
for parsing COFF files. This is a great header-only C++ library which 
has all functions I needed to read stuff from the object files. COFFI 
uses some of C++ Standard Library data structures like strings, vectors 
etc., and so does my code.</p>

<p>My algorithm goes like this:</p>
<ol>
  <li>Get pointers to <code class="language-plaintext highlighter-rouge">.text</code> section and relocations, directives, static data and symbol table.</li>
  <li>Calculate memory needed for assembly + static data + external function pointers (by iterating all <code class="language-plaintext highlighter-rouge">.text</code> relocations).</li>
  <li>Copy assembly to RW(X) memory.</li>
  <li>Copy static symbols right after the code (each symbol size is calculated by checking offset of the next one in a given section).</li>
  <li>While copying static symbols perform relocations (replace zeros in the assembly with relative addresses).</li>
  <li>Resolve all static functions by looking in libraries referenced in linker directives (<code class="language-plaintext highlighter-rouge">LoadLibrary</code> but <code class="language-plaintext highlighter-rouge">dll</code> not <code class="language-plaintext highlighter-rouge">lib</code> files), place addresses in the memory (right after static data; use <code class="language-plaintext highlighter-rouge">GetProcAddress</code>) and perform relocations. WinAPI function names are prefixed with <code class="language-plaintext highlighter-rouge">__imp_</code> in the COFF symbol table.</li>
  <li>Call the assembly start location (make sure the memory is executable - use <code class="language-plaintext highlighter-rouge">VirtualProtect</code> if necessary).</li>
</ol>

<h3 id="defining-additional-apis">Defining additional APIs</h3>
<p>Cobalt Strike’s BOF implement a set of functions which can be called 
from the injected object file code (aka Beacon API). We can do it, too.</p>

<p>The object file loaded can have an internal function defined, for example:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">COFF_API_Print</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">string</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>and added as an import to the object file code:</p>

<p><code class="language-plaintext highlighter-rouge">__declspec(dllimport) void COFF_API_Print(char* string);</code></p>

<p>It then has to be processed like WinAPI imports during loading.</p>

<h3 id="returning-a-value">Returning a value</h3>
<p>When calling the injected <code class="language-plaintext highlighter-rouge">main</code> function from an object file, we can access the returned value from the caller:</p>

<p><code class="language-plaintext highlighter-rouge">int returnedValue = ((int(*)())code)();</code></p>
<h3 id="caveats">Caveats</h3>
<ul>
  <li>This PoC code assumes that the object file contains only single function (<code class="language-plaintext highlighter-rouge">main</code>) and won’t work if there are other subroutines.</li>
  <li>The object file is compiled without C Runtime and there are no runtime initialization funcitons - <code class="language-plaintext highlighter-rouge">main</code> is the entry point. Also, code optimizations by compiler are disabled.</li>
</ul>

<h2 id="summary">Summary</h2>
<p>We’ve gained understanding of COFF object file format produced by 
MSVC compiler. Since these files contain all information needed to 
execute the code, they may be as well injected and executed in memory, 
delivered for example over a C&amp;C channel. This is a powerful 
technique that surely poses a challenge to malicious code detection 
capabilities.</p>

<p>The code is in <a href="https://github.com/0xpat/COFFInjector">my GitHub repo</a>.</p>

  </div>

  <div class="date">
    Written on March 16, 2021
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/0xPat"><i class="svg-icon github"></i></a>

<a href="https://www.linkedin.com/in/patryk-czeczko"><i class="svg-icon linkedin"></i></a>


<a href="https://www.twitter.com/0xPat"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    

  

</body></html>