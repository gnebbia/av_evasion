<!DOCTYPE html>
<html><head>
    <title>Malware development part 3 – 0xPat blog – Red/purple teamer</title>

        <meta charset="utf-8">
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

    
    <meta name="description" content="Introduction
This is the third post of a series which regards development of malicious software. In this series we will explore and try to implement multiple techniques used by malicious applications to execute code, hide from defenses and persist.
In the previous part of the series we discussed methods for detecting sandboxes, virtual machines and automated analysis.
This time let’s see how the application can detect that it’s being debugged or inspected by an analyst.

">
    <meta property="og:description" content="Introduction
This is the third post of a series which regards development of malicious software. In this series we will explore and try to implement multiple techniques used by malicious applications to execute code, hide from defenses and persist.
In the previous part of the series we discussed methods for detecting sandboxes, virtual machines and automated analysis.
This time let’s see how the application can detect that it’s being debugged or inspected by an analyst.

">
    
    <meta name="author" content="0xPat blog">

    
    <meta property="og:title" content="Malware development part 3">
    <meta property="twitter:title" content="Malware development part 3">
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="Malware%20development%20part%203%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/style.css">
    <link rel="alternate" type="application/rss+xml" title="0xPat blog - Red/purple teamer" href="https://0xpat.github.io/feed.xml">

  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          
          <div class="site-info">
            <h1 class="site-name"><a href="https://0xpat.github.io/">0xPat blog</a></h1>
            <p class="site-description">Red/purple teamer</p>
          </div>

          <nav>
            <a href="https://0xpat.github.io/">Blog</a>
            <a href="https://0xpat.github.io/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>Malware development part 3</h1>

  <div class="entry">
    <h2 id="introduction">Introduction</h2>
<p>This is the third post of a series which regards development of 
malicious software. In this series we will explore and try to implement 
multiple techniques used by malicious applications to execute code, hide
 from defenses and persist.<br>
In the previous part of the series we discussed methods for detecting sandboxes, virtual machines and automated analysis.<br>
This time let’s see how the application can detect that it’s being debugged or inspected by an analyst.</p>

<p>Note: we assume 64-bit execution environment - some code samples may 
not work for x86 applications (for example due to hardcoded 8-byte 
pointer length or different data layout in PE and PEB). Also, error 
checks and cleanups are ommited in the code samples below.</p>

<h2 id="detecting-and-hindering-manual-analysis">Detecting and hindering manual analysis</h2>
<p>There are specific characteristics indicating that the application is
 being manually inspected by a malware analyst. To protect our malware 
we can check for these traits and also we can make it harder for the 
analyst to reverse our code.</p>

<h3 id="detecting-debuggers">Detecting debuggers</h3>
<p>First thing to do is to check if the application is executed with a 
debugger attached. There are lots of techniques for debugging detection -
 we wil discuss some of them. Of course every technique can be mitigated
 by an analyst however some are more complicated than others.</p>

<h4 id="querying-information">Querying information</h4>

<p>It’s possible to simply “ask” the operating system if any debugger is attached. <code class="language-plaintext highlighter-rouge">IsDebuggerPresent</code> function basically checks <code class="language-plaintext highlighter-rouge">BeingDebugged</code> flag in the PEB:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">IsDebuggerPresent</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>
	
<span class="c1">// same check</span>
<span class="n">PPEB</span> <span class="n">pPEB</span> <span class="o">=</span> <span class="p">(</span><span class="n">PPEB</span><span class="p">)</span><span class="n">__readgsqword</span><span class="p">(</span><span class="mh">0x60</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">pPEB</span><span class="o">-&gt;</span><span class="n">BeingDebugged</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</code></pre></div></div>

<p>Another similar function is <code class="language-plaintext highlighter-rouge">CheckRemoteDebuggerPresent</code> which calls <code class="language-plaintext highlighter-rouge">NtQueryInformationProcess</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="n">isDebuggerPresent</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="n">CheckRemoteDebuggerPresent</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">isDebuggerPresent</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">isDebuggerPresent</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

<span class="c1">// same check</span>
<span class="k">typedef</span> <span class="nf">NTSTATUS</span><span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">PNtQueryInformationProcess</span><span class="p">)(</span><span class="n">IN</span>  <span class="n">HANDLE</span><span class="p">,</span> <span class="n">IN</span>  <span class="n">PROCESSINFOCLASS</span><span class="p">,</span> <span class="n">OUT</span> <span class="n">PVOID</span><span class="p">,</span> <span class="n">IN</span> <span class="n">ULONG</span><span class="p">,</span> <span class="n">OUT</span> <span class="n">PULONG</span><span class="p">);</span>
<span class="n">PNtQueryInformationProcess</span> <span class="n">pNtQueryInformationProcess</span> <span class="o">=</span> <span class="p">(</span><span class="n">PNtQueryInformationProcess</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleW</span><span class="p">(</span><span class="s">L"ntdll.dll"</span><span class="p">),</span> <span class="s">"NtQueryInformationProcess"</span><span class="p">);</span>
<span class="n">DWORD64</span> <span class="n">isDebuggerPresent2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">pNtQueryInformationProcess</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="n">ProcessDebugPort</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">isDebuggerPresent2</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">DWORD64</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">isDebuggerPresent2</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="flags-and-artifacts">Flags and artifacts</h4>

<p>There are some specific flags set in a process address space when it’s being debugged. <code class="language-plaintext highlighter-rouge">NtGlobalFlag</code> is a collection of flags located in the PEB which may indicate a debugger presence.</p>

<p>Note: This did not detect Visual Studio debugger (<code class="language-plaintext highlighter-rouge">msvsmon</code>).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">##define FLG_HEAP_ENABLE_TAIL_CHECK   0x10
##define FLG_HEAP_ENABLE_FREE_CHECK   0x20
##define FLG_HEAP_VALIDATE_PARAMETERS 0x40
##define NT_GLOBAL_FLAG_DEBUGGED (FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS)
</span><span class="n">PDWORD</span> <span class="n">pNtGlobalFlag</span> <span class="o">=</span> <span class="p">(</span><span class="n">PDWORD</span><span class="p">)(</span><span class="n">__readgsqword</span><span class="p">(</span><span class="mh">0x60</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0xBC</span><span class="p">);</span>
<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">pNtGlobalFlag</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">NT_GLOBAL_FLAG_DEBUGGED</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>

<p>Process heap contains two interesting flags <code class="language-plaintext highlighter-rouge">Flags</code> and <code class="language-plaintext highlighter-rouge">ForceFlags</code>
 which are affected by the debugger. When the process is debugged, these
 flags will have specific values. Heap location as well as flags 
location (relative to the heap) are system- and architecture-specific.</p>

<p>Note: This did not detect Visual Studio debugger (<code class="language-plaintext highlighter-rouge">msvsmon</code>).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PDWORD</span> <span class="n">pHeapFlags</span> <span class="o">=</span> <span class="p">(</span><span class="n">PDWORD</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">GetProcessHeap</span><span class="p">()</span> <span class="o">+</span> <span class="mh">0x70</span><span class="p">);</span>
<span class="n">PDWORD</span> <span class="n">pHeapForceFlags</span> <span class="o">=</span> <span class="p">(</span><span class="n">PDWORD</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">GetProcessHeap</span><span class="p">()</span> <span class="o">+</span> <span class="mh">0x74</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pHeapFlags</span> <span class="o">^</span> <span class="n">HEAP_GROWABLE</span> <span class="o">||</span> <span class="o">*</span><span class="n">pHeapForceFlags</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">NtQueryInformationProcess</code> function mentioned before can be used to check other artifacts: <code class="language-plaintext highlighter-rouge">ProcessDebugObjectHandle</code> and <code class="language-plaintext highlighter-rouge">ProcessDebugFlags</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">##define ProcessDebugObjectHandle 0x1E
##define ProcessDebugFlags 0x1F
</span><span class="n">HANDLE</span> <span class="n">hProcessDebugObject</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">DWORD</span> <span class="n">processDebugFlags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">pNtQueryInformationProcess</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">PROCESSINFOCLASS</span><span class="p">)</span><span class="n">ProcessDebugObjectHandle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hProcessDebugObject</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">HANDLE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">pNtQueryInformationProcess</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">PROCESSINFOCLASS</span><span class="p">)</span><span class="n">ProcessDebugFlags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processDebugFlags</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">DWORD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">hProcessDebugObject</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">processDebugFlags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="detecting-breakpoints-by-checking-the-code-for-changes">Detecting breakpoints by checking the code for changes</h4>

<p>When a <strong>software breakpoint</strong> is placed by a debugger in a function, an interrupt instruction is injected into the function code (<code class="language-plaintext highlighter-rouge">INT 3</code> - <code class="language-plaintext highlighter-rouge">0xCC</code> opcode). We can scan the function code during runtime to check if the <code class="language-plaintext highlighter-rouge">0xCC</code>
 opcode is present by comparing every byte with this value, or better, 
by calculating  a checksum of the function bytes and comparing it to a 
proper value (calculated for a “valid” function”). However we need to 
know where the function starts and where it ends. We can use a stub 
function located after our <code class="language-plaintext highlighter-rouge">CrucialFunction</code>. Also, we need to make sure that the linker does not link object files and libraries incrementally. <code class="language-plaintext highlighter-rouge">#pragma auto_inline(off)</code> is used to prevent functions from being compiled as inline.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">##pragma comment(linker, "/INCREMENTAL:YES")
</span>
<span class="n">DWORD</span> <span class="nf">CalculateFunctionChecksum</span><span class="p">(</span><span class="n">PUCHAR</span> <span class="n">functionStart</span><span class="p">,</span> <span class="n">PUCHAR</span> <span class="n">functionEnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DWORD</span> <span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">functionStart</span> <span class="o">&lt;</span> <span class="n">functionEnd</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">checksum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">functionStart</span><span class="p">;</span>
		<span class="n">functionStart</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">checksum</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">##pragma auto_inline(off)
</span><span class="n">VOID</span> <span class="nf">CrucialFunction</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">x</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">VOID</span> <span class="nf">AfterCrucialFunction</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">};</span>
<span class="cp">##pragma auto_inline(on)
</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">DWORD</span> <span class="n">originalChecksum</span> <span class="o">=</span> <span class="mi">3429</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">checksum</span> <span class="o">=</span> <span class="n">CalculateFunctionChecksum</span><span class="p">((</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">CrucialFunction</span><span class="p">,</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">AfterCrucialFunction</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">checksum</span> <span class="o">!=</span> <span class="n">originalChecksum</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
	
	<span class="n">wprintf_s</span><span class="p">(</span><span class="s">L"Now hacking...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Hardware breakpoints</strong> can be detected by examining debug registers <code class="language-plaintext highlighter-rouge">DR0</code> through <code class="language-plaintext highlighter-rouge">DR3</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CONTEXT</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">context</span><span class="p">.</span><span class="n">ContextFlags</span> <span class="o">=</span> <span class="n">CONTEXT_DEBUG_REGISTERS</span><span class="p">;</span>
<span class="n">GetThreadContext</span><span class="p">(</span><span class="n">GetCurrentThread</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">Dr0</span> <span class="o">||</span> <span class="n">context</span><span class="p">.</span><span class="n">Dr1</span> <span class="o">||</span> <span class="n">context</span><span class="p">.</span><span class="n">Dr2</span> <span class="o">||</span> <span class="n">context</span><span class="p">.</span><span class="n">Dr3</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="detecting-breakpoints-by-checking-memory-pages-permissions">Detecting breakpoints by checking memory pages permissions</h4>

<p>Checking memory pages permissions can help us detect software 
breakpoints places by a debugger. First we need to find the number of 
pages in the process working set and allocate large enough buffer to 
store all the information. Then we enumerate memory pages and check 
their permissions - we are only interested in executable pages. For each
 executable page we check if the if is <a href="https://waleedassar.blogspot.com/2014/06/sharecount-as-anti-debugging-trick.html">shared with any other process</a> (it shouldn’t be unless someone has modified the memory for example by placing a <code class="language-plaintext highlighter-rouge">INT 3</code> instruction in the code).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="n">debugged</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="n">PSAPI_WORKING_SET_INFORMATION</span> <span class="n">workingSetInfo</span><span class="p">;</span>
<span class="n">QueryWorkingSet</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">workingSetInfo</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">workingSetInfo</span><span class="p">);</span>
<span class="n">DWORD</span> <span class="n">requiredSize</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="n">PSAPI_WORKING_SET_INFORMATION</span> <span class="o">*</span> <span class="p">(</span><span class="n">workingSetInfo</span><span class="p">.</span><span class="n">NumberOfEntries</span> <span class="o">+</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">PPSAPI_WORKING_SET_INFORMATION</span> <span class="n">pWorkingSetInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PPSAPI_WORKING_SET_INFORMATION</span><span class="p">)</span><span class="n">VirtualAlloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">requiredSize</span><span class="p">,</span> <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span>
<span class="n">BOOL</span> <span class="n">s</span> <span class="o">=</span> <span class="n">QueryWorkingSet</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="n">pWorkingSetInfo</span><span class="p">,</span> <span class="n">requiredSize</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pWorkingSetInfo</span><span class="o">-&gt;</span><span class="n">NumberOfEntries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PVOID</span> <span class="n">physicalAddress</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)(</span><span class="n">pWorkingSetInfo</span><span class="o">-&gt;</span><span class="n">WorkingSetInfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VirtualPage</span> <span class="o">*</span> <span class="mi">4096</span><span class="p">);</span>
	<span class="n">MEMORY_BASIC_INFORMATION</span> <span class="n">memoryInfo</span><span class="p">;</span>
	<span class="n">VirtualQuery</span><span class="p">((</span><span class="n">PVOID</span><span class="p">)</span><span class="n">physicalAddress</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memoryInfo</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">memoryInfo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memoryInfo</span><span class="p">.</span><span class="n">Protect</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_EXECUTE</span> <span class="o">|</span> <span class="n">PAGE_EXECUTE_READ</span> <span class="o">|</span> <span class="n">PAGE_EXECUTE_READWRITE</span> <span class="o">|</span> <span class="n">PAGE_EXECUTE_WRITECOPY</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pWorkingSetInfo</span><span class="o">-&gt;</span><span class="n">WorkingSetInfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Shared</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">pWorkingSetInfo</span><span class="o">-&gt;</span><span class="n">WorkingSetInfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ShareCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">debugged</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">debugged</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

<span class="n">wprintf_s</span><span class="p">(</span><span class="s">L"Now hacking...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="exception-handlers">Exception handlers</h4>

<p>In general, exceptions are handled first by a debugger. If we could 
add new or modify exception processing routines (to execute arbitrary 
code) we would be able to discover a debugger presence, since our code 
will be executed only if there’s no debugger to catch the exception 
first.</p>

<p>Structured Exception Handling (SEH) is a Windows mechanism for, well, exception handling. 
When an exception is raised and no other facility was able to process it, the exception is passed to SEH. 
Manipulating SEH functions during runtime can be used to detect a debugger.</p>

<p>In x86 environment exception handlers are present in a form of linked
 list and the first element address is stored at the beginning of the 
TEB. We can add a custom handler and link it to the beginning of the 
list. The custom exception handler can indicate that the application is 
not being debugged.</p>

<p>However in x64 environment SEH operations are done in kernel mode 
(this protects the SEH data from being overwritten on the stack via a 
buffer overflow attack) so the aforementioned technique is generally not
 applicable. However if none of the handlers is able to process the 
exception, it is passed to <code class="language-plaintext highlighter-rouge">kernel32.UnhandledExceptionFilter</code> function (which is the last resort of exception handling).</p>

<p>It is possible to set a custom filter function that will be called from <code class="language-plaintext highlighter-rouge">UnhandledExceptionFilter</code> using <code class="language-plaintext highlighter-rouge">SetUnhandledExceptionFilter</code>
 function. Interestingly, our custom unhandled exception filter will be 
called only if the application is not being debugged. This happens 
because <code class="language-plaintext highlighter-rouge">UnhandledExceptionFilter</code> checks for the presence of a debugger using <code class="language-plaintext highlighter-rouge">pNtQueryInformationProcess</code> function with <code class="language-plaintext highlighter-rouge">ProcessDebugPort</code> flag (same as in the technique described before).</p>

<p>So, we can register arbitrary unhandled exception filter function which will indicate absence of a debugger.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="n">isDebugged</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

<span class="n">LONG</span> <span class="n">WINAPI</span> <span class="nf">CustomUnhandledExceptionFilter</span><span class="p">(</span><span class="n">PEXCEPTION_POINTERS</span> <span class="n">pExceptionPointers</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">isDebugged</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">EXCEPTION_CONTINUE_EXECUTION</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">PTOP_LEVEL_EXCEPTION_FILTER</span> <span class="n">previousUnhandledExceptionFilter</span> <span class="o">=</span> <span class="n">SetUnhandledExceptionFilter</span><span class="p">(</span><span class="n">CustomUnhandledExceptionFilter</span><span class="p">);</span>
	<span class="n">RaiseException</span><span class="p">(</span><span class="n">EXCEPTION_FLT_DIVIDE_BY_ZERO</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">SetUnhandledExceptionFilter</span><span class="p">(</span><span class="n">previousUnhandledExceptionFilter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isDebugged</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

	<span class="n">wprintf_s</span><span class="p">(</span><span class="s">L"Now hacking...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="creating-interrupts">Creating interrupts</h4>

<p>We can create breakpoint interrupt in our code which will be 
interpreted by the debugger as a software breakpoint (like it was set by
 a user). Let’s create simple SEH handler:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="n">isDebugged</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="kr">__try</span>
<span class="p">{</span>
	<span class="n">DebugBreak</span><span class="p">();</span>
<span class="p">}</span>
<span class="kr">__except</span> <span class="p">(</span><span class="n">GetExceptionCode</span><span class="p">()</span> <span class="o">==</span> <span class="n">EXCEPTION_BREAKPOINT</span> <span class="o">?</span> <span class="n">EXCEPTION_EXECUTE_HANDLER</span> <span class="o">:</span> <span class="n">EXCEPTION_CONTINUE_SEARCH</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">isDebugged</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">isDebugged</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</code></pre></div></div>

<p>This allowed to detect VS debugger (<code class="language-plaintext highlighter-rouge">msvsmon</code>) and <code class="language-plaintext highlighter-rouge">WinDbg</code> but not <code class="language-plaintext highlighter-rouge">x64dbg</code>. The latter seems to pass ‘breapoint’ exceptions to SEH.</p>

<p>Using <code class="language-plaintext highlighter-rouge">RaiseException</code> function instead of <code class="language-plaintext highlighter-rouge">DebugBreak</code> caused some undefined behavior - debuggers were messing the code flow and producing loops of <code class="language-plaintext highlighter-rouge">EXCEPTION_ILLEGAL_INSTRUCTION</code> exceptions by jumping to incorrect addresses. This may be useful for us to make the application analysis harder.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="n">isDebugged</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="kr">__try</span>
<span class="p">{</span>
	<span class="n">RaiseException</span><span class="p">(</span><span class="n">EXCEPTION_BREAKPOINT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="kr">__except</span> <span class="p">(</span><span class="n">GetExceptionCode</span><span class="p">()</span> <span class="o">==</span> <span class="n">EXCEPTION_BREAKPOINT</span> <span class="o">?</span> <span class="n">EXCEPTION_EXECUTE_HANDLER</span> <span class="o">:</span> <span class="n">EXCEPTION_CONTINUE_SEARCH</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">isDebugged</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">isDebugged</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</code></pre></div></div>

<p>Another way to see how debugger handles such a breakpoint interrupt is to register a vectored exception handler.</p>

<p>Vectored Exception Handling is an extension to SEH. Vectored 
exception handlers do not replace SEH - they work in parallel, however 
VEH has priority over SEH - VEH handlers are called before SEH handlers.
 Anyway, VEH may or may not be called after the debugger has handled (or
 not) the breakpoint exception.</p>

<p>Using <code class="language-plaintext highlighter-rouge">DebugBreak</code>
 function I was able to reproduce similar situation to the one with SEH 
(VEH was only executed if no specific debugger was present). This 
allowed to detect VS debugger (<code class="language-plaintext highlighter-rouge">msvsmon</code>) and <code class="language-plaintext highlighter-rouge">WinDbg</code> but not <code class="language-plaintext highlighter-rouge">x64dbg</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="n">isDebugged</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

<span class="n">LONG</span> <span class="n">WINAPI</span> <span class="nf">CustomVectoredExceptionHandler</span><span class="p">(</span><span class="n">PEXCEPTION_POINTERS</span> <span class="n">pExceptionPointers</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pExceptionPointers</span><span class="o">-&gt;</span><span class="n">ExceptionRecord</span><span class="o">-&gt;</span><span class="n">ExceptionCode</span> <span class="o">==</span> <span class="n">EXCEPTION_BREAKPOINT</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pExceptionPointers</span><span class="o">-&gt;</span><span class="n">ContextRecord</span><span class="o">-&gt;</span><span class="n">Rip</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">EXCEPTION_CONTINUE_EXECUTION</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">EXCEPTION_CONTINUE_SEARCH</span><span class="p">;</span> <span class="c1">// pass on other exceptions</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">AddVectoredExceptionHandler</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">CustomVectoredExceptionHandler</span><span class="p">);</span>
	<span class="n">DebugBreak</span><span class="p">();</span>
	<span class="n">RemoveVectoredExceptionHandler</span><span class="p">(</span><span class="n">CustomVectoredExceptionHandler</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isDebugged</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

	<span class="n">wprintf_s</span><span class="p">(</span><span class="s">L"Now hacking...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Again, <code class="language-plaintext highlighter-rouge">RaiseException</code> function caused some undefined behavior - <code class="language-plaintext highlighter-rouge">EXCEPTION_ILLEGAL_INSTRUCTION</code> exceptions looped. Let’s use this to just hinder analysis:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LONG</span> <span class="n">WINAPI</span> <span class="nf">CustomVectoredExceptionHandler</span><span class="p">(</span><span class="n">PEXCEPTION_POINTERS</span> <span class="n">pExceptionPointers</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// process all exceptions, including EXCEPTION_ILLEGAL_INSTRUCTION</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"xD"</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">EXCEPTION_CONTINUE_EXECUTION</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">AddVectoredExceptionHandler</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">CustomVectoredExceptionHandler</span><span class="p">);</span>
	<span class="n">RaiseException</span><span class="p">(</span><span class="n">EXCEPTION_BREAKPOINT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">RemoveVectoredExceptionHandler</span><span class="p">(</span><span class="n">CustomVectoredExceptionHandler</span><span class="p">);</span>
	
	<span class="n">wprintf_s</span><span class="p">(</span><span class="s">L"Now hacking...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="self-debugging">Self-debugging</h4>

<p>If a process is being debugged, it is impossible to attach another 
debugger to it. To check if our application is debugged leveraging this 
fact we would need to start another process which would try to attach to
 the application.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DebugActiveProcess</span><span class="p">(</span><span class="n">pid</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">HANDLE</span> <span class="n">hProcess</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_TERMINATE</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
	<span class="n">TerminateProcess</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="detecting-analysis-in-general">Detecting analysis in general</h3>

<p>By enumerating resources like running processes, loaded libraries 
etc. we may discover an analyst trying to reverse engineer our 
application. See the previous article (<strong>File, directory, process and window names</strong> section) for more details.</p>

<h4 id="execution-time">Execution time</h4>

<p>Time checks described in the previous article (as a part of sandbox 
evasion) can also be used to detect if the application is being analyzed
 or debugged. We can check system time before and after a certain 
instruction block and assume that the time measured elapsed time should 
be less than some value. If the application is being analyzed, it is 
likely that breakpoints are set in that instruction block. If so, the 
execution time will exceed the assumed period.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">GetTickCount64</span><span class="p">();</span>
<span class="n">Hack</span><span class="p">();</span> <span class="c1">// should take less than 5 seconds</span>
<span class="kt">int</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">GetTickCount64</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(((</span><span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> 

<span class="n">wprintf_s</span><span class="p">(</span><span class="s">L"Now hacking more...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">GetTickCount64</code> function may be subject to function hooking. To handle this we can use techniques described in the previous article (see <strong>Delaying execution</strong> and <strong>Function hooking</strong>).</p>

<h3 id="making-analysts-life-harder">Making analyst’s life harder</h3>

<h4 id="hiding-from-the-debugger">Hiding from the debugger</h4>

<p>We can use native Windows functionality to hide a thread from the 
debugger - the thread will stop sending events. Function that we use for
 hiding the thread (<code class="language-plaintext highlighter-rouge">NtSetInformationThread</code>) may be hooked - to verify we can call it with some bogus parameters and check return status (should not return <code class="language-plaintext highlighter-rouge">STATUS_SUCCESS</code> for incorrect parameters).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">NTSTATUS</span><span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">NtSetInformationThread</span><span class="p">)(</span><span class="n">IN</span> <span class="n">HANDLE</span><span class="p">,</span> <span class="n">IN</span> <span class="n">THREADINFOCLASS</span><span class="p">,</span> <span class="n">IN</span> <span class="n">PVOID</span><span class="p">,</span> <span class="n">IN</span> <span class="n">ULONG</span><span class="p">);</span>
<span class="n">NtSetInformationThread</span> <span class="n">pNtSetInformationThread</span> <span class="o">=</span> <span class="p">(</span><span class="n">NtSetInformationThread</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleW</span><span class="p">(</span><span class="s">L"ntdll.dll"</span><span class="p">),</span> <span class="s">"NtSetInformationThread"</span><span class="p">);</span>
<span class="n">THREADINFOCLASS</span> <span class="n">ThreadHideFromDebugger</span> <span class="o">=</span> <span class="p">(</span><span class="n">THREADINFOCLASS</span><span class="p">)</span><span class="mh">0x11</span><span class="p">;</span>
<span class="n">pNtSetInformationThread</span><span class="p">(</span><span class="n">GetCurrentThread</span><span class="p">(),</span> <span class="n">ThreadHideFromDebugger</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>Of course this does not affect events that are sent before hiding the thread.</p>

<p>Similarly, we can create a new thread which will be hidden from a debugger using <code class="language-plaintext highlighter-rouge">NtCreateThreadEx</code> function. The new thread will not send events to the debugger.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">NTSTATUS</span><span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">NtCreateThreadEx</span><span class="p">)(</span><span class="n">OUT</span> <span class="n">PHANDLE</span><span class="p">,</span> <span class="n">IN</span> <span class="n">ACCESS_MASK</span><span class="p">,</span> <span class="n">IN</span> <span class="n">PVOID</span><span class="p">,</span> <span class="n">IN</span> <span class="n">HANDLE</span><span class="p">,</span> <span class="n">IN</span> <span class="n">PTHREAD_START_ROUTINE</span><span class="p">,</span> <span class="n">IN</span> <span class="n">PVOID</span><span class="p">,</span> <span class="n">IN</span> <span class="n">ULONG</span><span class="p">,</span> <span class="n">IN</span> <span class="n">SIZE_T</span><span class="p">,</span> <span class="n">IN</span> <span class="n">SIZE_T</span><span class="p">,</span> <span class="n">IN</span> <span class="n">SIZE_T</span><span class="p">,</span> <span class="n">OUT</span> <span class="n">PVOID</span><span class="p">);</span>
<span class="n">NtCreateThreadEx</span> <span class="n">pNtCreateThreadEx</span> <span class="o">=</span> <span class="p">(</span><span class="n">NtCreateThreadEx</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleW</span><span class="p">(</span><span class="s">L"ntdll.dll"</span><span class="p">),</span> <span class="s">"NtCreateThreadEx"</span><span class="p">);</span>
<span class="cp">##define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER 0x4
</span><span class="n">HANDLE</span> <span class="n">hThread</span><span class="p">;</span>
<span class="n">pNtCreateThreadEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hThread</span><span class="p">,</span> <span class="mh">0x1FFFFF</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">PTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">shellcode_exec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
</code></pre></div></div>

<p>Creating a new thread is by itself a way to complicate the 
application analysis. Code in a new thread executes freely unless a 
breakpoint is set in an appropriate location.</p>

<h4 id="execution-path">Execution path</h4>

<p>We can make the application analysis more difficult by tangling the 
code execution path. Exception handlers mentioned before are a good and 
not-so-obvious place to execute malicious code. We can also leverage 
Windows API functions that use callbacks (remember <code class="language-plaintext highlighter-rouge">EnumDisplayMonitors</code>?). There are <a href="https://secrary.com/Random/HinderMalwareAnalyst/">many functions</a> using callbacks, for example extended file read and write routines:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VOID</span> <span class="n">CALLBACK</span> <span class="nf">MyCallback</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">errorCode</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">bytesTransferred</span><span class="p">,</span> <span class="n">POVERLAPPED</span> <span class="n">pOverlapped</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">MessageBoxW</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">L"Catch me if you can"</span><span class="p">,</span> <span class="s">L"xD"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">HANDLE</span> <span class="n">hFile</span> <span class="o">=</span> <span class="n">CreateFileW</span><span class="p">(</span><span class="s">L"C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">win.ini"</span><span class="p">,</span> <span class="n">GENERIC_READ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">OPEN_EXISTING</span><span class="p">,</span> <span class="n">FILE_FLAG_OVERLAPPED</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">PVOID</span> <span class="n">fileBuffer</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span>
	<span class="n">OVERLAPPED</span> <span class="n">overlapped</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="n">ReadFileEx</span><span class="p">(</span><span class="n">hFile</span><span class="p">,</span> <span class="n">fileBuffer</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">overlapped</span><span class="p">,</span> <span class="n">MyCallback</span><span class="p">);</span>

	<span class="n">WaitForSingleObjectEx</span><span class="p">(</span><span class="n">hFile</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span> <span class="c1">// wait for the asynchronous operation to finish</span>
	<span class="n">wprintf_s</span><span class="p">(</span><span class="s">L"Already pwned...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="tls-callbacks">TLS callbacks</h4>

<p>TLS (thread local storage) callbacks is a Windows mechanism that 
allows execution of arbitrary code on process and threads start and 
termination. It can be used to run some anti-debug code before <code class="language-plaintext highlighter-rouge">main</code> function (or other entry point). However most debuggers automatically place breakpoint before <code class="language-plaintext highlighter-rouge">main</code> (“System breakpoint” - <code class="language-plaintext highlighter-rouge">ntdll.LdrpDoDebuggerBreak</code>) or even at the beginning of the callback. Anyway, the callback implementation requires certain linker directives:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">NTAPI</span> <span class="nf">TlsCallback</span><span class="p">(</span><span class="n">PVOID</span> <span class="n">DllHandle</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">dwReason</span><span class="p">,</span> <span class="n">PVOID</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dwReason</span> <span class="o">==</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">CheckIfDebugged</span><span class="p">())</span> <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">##pragma comment (linker, "/INCLUDE:_tls_used")
##pragma comment (linker, "/INCLUDE:tls_callback_function")
</span>
<span class="cp">##pragma const_seg(".CRT$XLA")
</span><span class="n">EXTERN_C</span> <span class="k">const</span> <span class="n">PIMAGE_TLS_CALLBACK</span> <span class="n">tls_callback_function</span> <span class="o">=</span> <span class="n">TlsCallback</span><span class="p">;</span>
<span class="cp">##pragma const_seg()
</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">wprintf_s</span><span class="p">(</span><span class="s">L"Now hacking...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>On older Windows versions, TLS callbacks could be used to detect new 
threads created in a process by a debugger. Since Windows 7, <code class="language-plaintext highlighter-rouge">DebugActiveProcess</code> calls <code class="language-plaintext highlighter-rouge">NtCreateThreadEx</code> with a flag  that causes <code class="language-plaintext highlighter-rouge">SkipThreadAttach</code> flag to be set in a new thread’s environment block, which in turn prevents TLS callback execution.</p>

<h4 id="blocking-user-input">Blocking user input</h4>

<p>We can block keyboard and mouse events. This works only in high 
integrity context (i.e. must be “run as administrator”). The block can 
be bypassed by the secure attention sequence (<code class="language-plaintext highlighter-rouge">CTRL+ALT+DEL</code>) which gets captured by kernel.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BlockInput</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="summary">Summary</h2>
<p>That’s it - we are ready to implement some debugger detection 
techniques in our code. Of course every trick can be disabled by a 
skilled reverser. We can’t make debugging of our application impossible,
 but we can make it more difficult. And that’s the point - the longer it
 takes to understand our code and extract IoCs, the more time we have to
 infect users and pwn systems.</p>

<p>In the next article we will talk about static analysis and obfuscation of our malicious application, focusing on the PE format.</p>

<h3 id="links">Links</h3>

<p>Be sure to check these great resources on the topic:</p>

<p><a href="https://www.apriorit.com/dev-blog/367-anti-reverse-engineering-protection-techniques-to-use-before-releasing-software">https://www.apriorit.com/dev-blog/367-anti-reverse-engineering-protection-techniques-to-use-before-releasing-software</a></p>

<p><a href="https://anti-reversing.com/Downloads/Anti-Reversing/The_Ultimate_Anti-Reversing_Reference.pdf">https://anti-reversing.com/Downloads/Anti-Reversing/The_Ultimate_Anti-Reversing_Reference.pdf</a></p>

<p><a href="http://antukh.com/blog/2015/01/19/malware-techniques-cheat-sheet/">http://antukh.com/blog/2015/01/19/malware-techniques-cheat-sheet/</a></p>

<p><a href="https://github.com/LordNoteworthy/al-khaser/tree/master/al-khaser/AntiDebug">https://github.com/LordNoteworthy/al-khaser/tree/master/al-khaser/AntiDebug</a></p>

<p><a href="https://secrary.com/Random/HinderMalwareAnalyst/">https://secrary.com/Random/HinderMalwareAnalyst/</a></p>

  </div>

  <div class="date">
    Written on April  6, 2020
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/0xPat"><i class="svg-icon github"></i></a>

<a href="https://www.linkedin.com/in/patryk-czeczko"><i class="svg-icon linkedin"></i></a>


<a href="https://www.twitter.com/0xPat"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    

  

</body></html>