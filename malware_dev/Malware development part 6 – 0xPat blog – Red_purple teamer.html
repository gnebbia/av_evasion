<!DOCTYPE html>
<html><head>
    <title>Malware development part 6 – 0xPat blog – Red/purple teamer</title>

        <meta charset="utf-8">
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

    
    <meta name="description" content="Introduction
This is the sixth post of a series which regards the development of malicious software. In this series we will explore and try to implement multiple techniques used by malicious applications to execute code, hide from defenses and persist.
Today we will explore anti-disassembly obfuscation using LLVM and template metaprogramming.

">
    <meta property="og:description" content="Introduction
This is the sixth post of a series which regards the development of malicious software. In this series we will explore and try to implement multiple techniques used by malicious applications to execute code, hide from defenses and persist.
Today we will explore anti-disassembly obfuscation using LLVM and template metaprogramming.

">
    
    <meta name="author" content="0xPat blog">

    
    <meta property="og:title" content="Malware development part 6">
    <meta property="twitter:title" content="Malware development part 6">
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="Malware%20development%20part%206%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/style.css">
    <link rel="alternate" type="application/rss+xml" title="0xPat blog - Red/purple teamer" href="https://0xpat.github.io/feed.xml">

  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          
          <div class="site-info">
            <h1 class="site-name"><a href="https://0xpat.github.io/">0xPat blog</a></h1>
            <p class="site-description">Red/purple teamer</p>
          </div>

          <nav>
            <a href="https://0xpat.github.io/">Blog</a>
            <a href="https://0xpat.github.io/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>Malware development part 6</h1>

  <div class="entry">
    <h2 id="introduction">Introduction</h2>
<p>This is the sixth post of a series which regards the development of 
malicious software. In this series we will explore and try to implement 
multiple techniques used by malicious applications to execute code, hide
 from defenses and persist.<br>
Today we will explore anti-disassembly obfuscation using LLVM and template metaprogramming.</p>

<h2 id="llvm-obfuscation">LLVM obfuscation</h2>
<p>LLVM is a compiler infrastructure. To understand what it is exactly 
we need to dive into compilation process (this is most accurate for 
unmanaged code like C/C++).</p>

<p>We can distinguish three steps of assembly generation from the source code:</p>
<ol>
  <li>Front end, which includes:
    <ul>
      <li>scanner, which performs lexical analysis of the code and produces tokens (strings with certain meaning)</li>
      <li>parser, which produces an abstract syntax tree (tokens grouped
 in a tree which represents the actual algorithm implemented in the 
source code)</li>
      <li>semantic analysis (mainly type checking), during which the AST
 is checked for errors like wrong use of types or use of variables 
before initialization</li>
      <li>generation of intermediate representation, usually based on AST</li>
    </ul>
  </li>
  <li>Optimization, which aims at reducing code complexity for example 
by precalculating stuff. Optimization must not change the 
algorithm/program itself.</li>
  <li>Back end, which translates the intermediate representation to expected output (assembly or bytecode).</li>
</ol>

<p>The core of LLVM is the optimizer but the project also includes a compiler front end - <code class="language-plaintext highlighter-rouge">clang</code> - which is intended to be used with the LLVM toolchain.</p>

<h3 id="obfuscator-llvm">Obfuscator-LLVM</h3>
<p>We will leverage <a href="https://github.com/obfuscator-llvm/obfuscator"><code class="language-plaintext highlighter-rouge">Obfuscator-LLVM</code></a> project which is an open-source fork of the LLVM.</p>

<p>Obfuscation works on the mentioned intermediate representation (IR) level. In other words it’s a kind of ‘anti’-optimization. <code class="language-plaintext highlighter-rouge">Clang</code> is used to generate IR from source code, then the IR is processed to obfuscate code flow and finally the assembly is generated.</p>

<h3 id="setup">Setup</h3>
<p>Having gone through the theoretical introduction, let’s prepare the 
environment for C++ code obfuscation. The Obfuscator-LLVM needs to be 
downloaded and compiled. The latest branch is <code class="language-plaintext highlighter-rouge">llvm-4.0</code> (from 2017, the latest version of LLVM is <code class="language-plaintext highlighter-rouge">11.0</code>
 nowadays) and the code needs to be compiled with Visual Studio 2017 and
 not 2019 (as it gives some errors during compilation). We need to use <code class="language-plaintext highlighter-rouge">CMake</code> to generate VS2017 project and then compile it (minding the target architecture). We can use <code class="language-plaintext highlighter-rouge">Developer Command Prompt for VS 2017</code> which is a part of Visual Studio 2017:</p>

<div class="language-bat highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">git</span> <span class="kd">clone</span> <span class="na">-b </span><span class="kd">llvm</span><span class="o">-</span><span class="m">4</span>.0 <span class="kd">https</span>://github.com/obfuscator<span class="na">-llvm/obfuscator
</span><span class="nb">cd</span> <span class="kd">obfuscator</span>
<span class="nb">mkdir</span> <span class="kd">build</span>
<span class="nb">cd</span> <span class="kd">build</span>
<span class="kd">cmake</span> <span class="na">-G </span><span class="s2">"Visual Studio 15 2017 Win64"</span> ..
</code></pre></div></div>

<p>Note: I had to manually define <code class="language-plaintext highlighter-rouge">ENDIAN_LITTLE</code>identifier to get rid of some compilation errors.</p>

<p>There are different ways to use <code class="language-plaintext highlighter-rouge">Obfuscator-LLVM</code> compiler:</p>
<ul>
  <li>use manually via command line</li>
  <li>add the compiler as a <em>custom build tool</em> for <code class="language-plaintext highlighter-rouge">.cpp</code> and other files in Visual Studio (in a relevant file <em>Property Pages</em>)</li>
  <li>use VS Installer to install a <code class="language-plaintext highlighter-rouge">clang-cl</code> platform toolset and manually swap Visual Studio’s clang version with the compiled compiler <a href="https://en.wikipedia.org/wiki/Bootstrapping_(compilers)">(this kinda sounds like a chicken-egg problem :))</a></li>
</ul>

<h3 id="usage-and-features">Usage and features</h3>
<p>Let’s write a simple program which performs some rather simple calculations based on a pseudorandom value:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">GetTickCount64</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">c</span> <span class="o">+=</span> <span class="n">a</span> <span class="o">%</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note: I compiled this code without <code class="language-plaintext highlighter-rouge">CRT</code> dependency so the binary is small and there’s no additional code (like <code class="language-plaintext highlighter-rouge">mainCRTStartup</code> etc.) - see part 4 of malware development series.</p>

<p>This is how the code looks like after decompiling with Ghidra:</p>

<p><img src="Malware%20development%20part%206%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/plain_decompiled.png" alt="plain_decompiled.png"></p>

<p>And the program graph:</p>

<p><img src="Malware%20development%20part%206%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/plain_graph.png" alt="plain_graph.png"></p>

<p><code class="language-plaintext highlighter-rouge">Obfuscator-LLVM</code>
 has 3 code obfuscation features: instructions substitution, bogus 
control flow and control flow flattening. Let’s explore them. Details 
can be found <a href="https://github.com/obfuscator-llvm/obfuscator/wiki/Features">in the project’s repository</a></p>

<p>These features use random value which has to be provided as a command line parameter (<code class="language-plaintext highlighter-rouge">-mllvm -aesSeed=1234567890ABCDEF1234567890ABCDEF</code>) on Windows systems (on Linux it uses <code class="language-plaintext highlighter-rouge">/dev/random</code>).</p>

<h4 id="instructions-substitution">Instructions substitution</h4>
<p>This replaces simple arithmetic operations with more complex but equivalent ones. For example: <code class="language-plaintext highlighter-rouge">a = b + c</code> may be changed to <code class="language-plaintext highlighter-rouge">r = rand(); a = b + r; a = a + c; a = a - r;</code>. The random value is calculated during the compilation.</p>

<p>It’s possible to apply substitutions multiple times. Random seed from
 the command line is used to randomly select substitute instruction 
sequence so this brings some additional uniqueness to the resulting 
binary.</p>

<p>Let’s add following switches to the compilation command line: <code class="language-plaintext highlighter-rouge">-mllvm -sub -mllvm -sub_loop=5 -mllvm -aesSeed=1234567890ABCDEF1234567890ABCDEF</code></p>

<p>Resulting assembly (decompiled):</p>

<p><img src="Malware%20development%20part%206%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/sub_decompiled.png" alt="sub_decompiled.png"></p>

<p>And the graph:</p>

<p><img src="Malware%20development%20part%206%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/sub_graph.png" alt="sub_graph.png"></p>

<p>Note here that the Ghidra decompiler handled obfuscator ‘deoptimizations’ quite well.</p>

<h4 id="bogus-control-flow">Bogus control flow</h4>
<p>This adds opaque predicates before instruction blocks. An opaque 
predicate is basically a portion of (prefably random) code which is 
evaluated at the runtime to a predetermined logical value (<code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code>). It is followed by a conditional jump which points to an original instruction block.</p>

<p>This obfuscation can also be applied multiple times, and can target random blocks of code.</p>

<p>Example usage: <code class="language-plaintext highlighter-rouge">-mllvm -bcf -mllvm -bcf_prob=100 -mllvm -bcf_loop=1 -mllvm -aesSeed=1234567890ABCDEF1234567890ABCDEF</code></p>

<p>Resulting assembly (decompiled):</p>

<p><img src="Malware%20development%20part%206%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/bcf_decompiled.png" alt="bcf_decompiled.png"></p>

<p>And the graph:</p>

<p><img src="Malware%20development%20part%206%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/bcf_graph.png" alt="bcf_graph.png"></p>

<h4 id="control-flow-flattening">Control flow flattening</h4>
<p>This one disrupts the sequence of instructions block by placing them on the same level in a looped <code class="language-plaintext highlighter-rouge">switch</code>
 statement. Additional variables are defined which actually control the 
order of execution. See the diagram below - it should make this more 
clear:</p>

<p><img src="Malware%20development%20part%206%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/cff.png" alt="cff.png"></p>

<p>This obfuscation can also be applied multiple times on.a single block.</p>

<p>Example usage: <code class="language-plaintext highlighter-rouge">-mllvm -fla -mllvm -split -mllvm -aesSeed=1234567890ABCDEF1234567890ABCDEF</code></p>

<p>Resulting assembly (decompiled):</p>

<p><img src="Malware%20development%20part%206%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/cff_decompiled.png" alt="cff_decompiled.png"></p>

<p>And the graph:</p>

<p><img src="Malware%20development%20part%206%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/cff_graph.png" alt="cff_graph.png"></p>

<h3 id="testing">Testing</h3>
<p>Now let’s compile and obfuscate some simple malware. Remember the 
simplest shellcode injector from the part 1 of the series? LLVM 
obfuscation won’t do much with it because the most obvious indicators 
(shellcode and imports) will be still present and intact.</p>

<p>Thst’s why we will test another code - for example <a href="https://github.com/sh3llc0d3r1337/windows_reverse_shell_1/blob/master/ReverseShell.cpp">this classic reverse shell</a>. Actually this uses the same method as the <code class="language-plaintext highlighter-rouge">shell_reverse_tcp</code> shellcode (create an IP socket and create cmd process with its standard streams attached to the socket).</p>

<p>Interestingly, uploading compiled binaries to VirusTotal resulted in 
only one detection for the code compiled without obfuscation and 6 
detections when multiple obfuscation methods were applied.</p>

<h3 id="conclusion">Conclusion</h3>
<p><code class="language-plaintext highlighter-rouge">Obfuscator-LLVM</code>
 is a great resource to learn and understand what actually happens 
during the code compilation and how can this process be modified to make
 static assembly analysis more difficult and time-consuming. However 
it’s important to remember that the IR-level obfuscation can be reversed
 (not completely, but still). See <a href="https://blog.quarkslab.com/deobfuscation-recovering-an-ollvm-protected-program.html">this great article</a> for an example of the deobfuscation process.</p>

<p>Here are some general thoughts and considerations: From an offensive 
penetration tester perspective, it’s important to combine multiple 
layers of code protection measures to minimize chances of detection and 
hinder manual analysis as much as possible (well, with a reasonable 
ammount of our efforts). This helps to deliver effective adversary 
emulations focused on the actual objectives. Of course more advanced 
malware requires more work put into it by defensive teams, which is also
 a good thing.</p>

<p>Anyway, make sure to consider implementing some intermediate 
representation level obfuscation into your offensive tooling build 
process.</p>

<h3 id="other-llvm-based-obfuscators">Other LLVM-based obfuscators</h3>
<p>Also be sure to check other LLVM-based obfuscators and articles on building custom obfuscators with LLVM:</p>

<p><a href="https://github.com/HikariObfuscator/Hikari/">https://github.com/HikariObfuscator/Hikari/</a></p>

<p><a href="https://medium.com/@polarply/build-your-first-llvm-obfuscator-80d16583392b">https://medium.com/@polarply/build-your-first-llvm-obfuscator-80d16583392b</a></p>

<p><a href="http://www.babush.me/dumbo-llvm-based-dumb-obfuscator.html">http://www.babush.me/dumbo-llvm-based-dumb-obfuscator.html</a></p>

<p><a href="https://github.com/emc2314/YANSOllvm">https://github.com/emc2314/YANSOllvm</a></p>

<p><a href="https://blog.scrt.ch/2020/06/19/engineering-antivirus-evasion/">https://blog.scrt.ch/2020/06/19/engineering-antivirus-evasion/</a></p>

<p><a href="https://blog.scrt.ch/2020/07/15/engineering-antivirus-evasion-part-ii/">https://blog.scrt.ch/2020/07/15/engineering-antivirus-evasion-part-ii/</a></p>

<h2 id="template-metaprogramming">Template metaprogramming</h2>
<p>Before diving into the details of C++ constructs like templates, 
constant expressions and metaprogramming, let’s consider a simple case: 
we have a source code with some string literals (like IP addresses, 
domain names etc.) that need to be obfuscated so they are invisible in 
the assembly and only revealed at runtime. Easiest thing to do here is 
to encrypt these literals and replace them with a call to decryption 
routine, for example:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">address</span> <span class="o">=</span> <span class="s">"www.example.com"</span><span class="p">;</span>
</code></pre></div></div>

<p>replaced with:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span><span class="o">*</span> <span class="nf">Decrypt</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">);</span>
<span class="p">(...)</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">Decrypt</span><span class="p">(</span><span class="s">"xxx.yyyyyyy.zzz"</span><span class="p">);</span>
</code></pre></div></div>

<p>Of course we would have to consider string length, null-byte terminators etc.</p>

<p>We would prefer to use plaintext values in the source code and 
obfuscate/encrypt them automatically during the build process. 
Replacement of plain strings with encrypted ones can be automated with a
 pre-build task, e.g. some Python script. But there’s another, cooler 
way to do this.</p>
<h3 id="introduction-1">Introduction</h3>
<p>Let’s get familiar with some features introduced in <code class="language-plaintext highlighter-rouge">C++11</code> standard: <code class="language-plaintext highlighter-rouge">template</code>s and <code class="language-plaintext highlighter-rouge">constexpr</code>essions.
 The following won’t cover all the details of metaprogramming concepts -
 it’s just a simple introduction which will help to understand how 
obfuscation based on template metaprogramming actually work.</p>
<h4 id="templates">Templates</h4>
<p>Templates are functions that operate on generic types. Templates 
allow simple creation of functions which operate on multiple types 
(basic types, structs, classes). For example we can use the following 
template:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">bool</span> <span class="nf">Equal</span><span class="p">(</span><span class="n">T</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">T</span> <span class="n">arg2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">arg1</span> <span class="o">==</span> <span class="n">arg2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>instead of defining overloaded functions:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bool</span> <span class="nf">Equal</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">);</span>
<span class="n">bool</span> <span class="nf">Equal</span><span class="p">(</span><span class="kt">double</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">arg2</span><span class="p">);</span>
</code></pre></div></div>

<p>And example template usage:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Equal</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
</code></pre></div></div>

<p>Of course types must implement <code class="language-plaintext highlighter-rouge">==</code> operator in order to use the <code class="language-plaintext highlighter-rouge">Equal</code> function template.</p>

<p>Templates can be also used to create a generic struct or class, which then can be instantiated to be used with a specific type:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Stack</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">object</span><span class="p">);</span>
	<span class="n">T</span><span class="o">*</span> <span class="n">pop</span><span class="p">();</span>
<span class="p">};</span>

<span class="n">Stack</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span> <span class="n">fruitStack</span><span class="p">;</span>
<span class="n">Stack</span><span class="o">&lt;</span><span class="n">Vegetable</span><span class="o">&gt;</span> <span class="n">vegetableStack</span><span class="p">;</span>
</code></pre></div></div>

<p>This also provides type safety, in this case you won’t be able to mix fruits with vegetables - <code class="language-plaintext highlighter-rouge">fruitStack.push(new Vegetable());</code> will produce a compilation error.</p>

<p>Let’s see an another example - usage of template for recursive factorial calculation:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Factorial</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span> <span class="p">};</span>
<span class="p">};</span>

<span class="n">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>
<span class="p">};</span>

<span class="n">Factorial</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;::</span><span class="n">value</span> <span class="c1">// 5! = 120</span>
</code></pre></div></div>

<p>We see here that an integer can be a template argument and that a template <strong>specialization</strong> (<code class="language-plaintext highlighter-rouge">template &lt;&gt;</code>) is needed to define a value for a specific argument.</p>

<h4 id="constant-expressions">Constant expressions</h4>
<p>The <code class="language-plaintext highlighter-rouge">constexpr</code>
 specifier indicates that the value of some expression can be evaluated 
at compile time. For example, when such a constant expression defined:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">constexpr</span> <span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Sum(1+2)</code> will be precalculated at compile time - this calculation won’t consume resources at the application’s runtime.</p>

<h4 id="metaprogramming">Metaprogramming</h4>
<p>Metaprogramming is just modifying programs by other programs or by 
themselves. Turns out that templates are a kind of functional 
programming language and can be used by compiler to generate source 
code.</p>

<p>Remember? It’s exactly what we were doing with pre-build scripts - 
creating a temporary source code with sensitive data obfuscated.</p>

<h3 id="string-obfuscation">String obfuscation</h3>
<p>Having understood the ability to write code which can be executed by 
compilers, let’s create a simple string obfuscator which will replace 
plaintext data with XORed values just before compilation. We would like 
to use the obfuscation in the following manner: <code class="language-plaintext highlighter-rouge">Obfuscated("secret");</code>. The <code class="language-plaintext highlighter-rouge">Obfuscated</code> macro should replace the <code class="language-plaintext highlighter-rouge">"secret"</code> with a decryption function with an encrypted argument: <code class="language-plaintext highlighter-rouge">Decrypt_runtime(Encrypt_compiletime(secret))</code>.</p>

<p>To use constant string at compile time, we need to know its exact 
length. So we will need a compile time function which operates on this 
length value. So first, we need to create a template which will get an 
integer as an argument: <code class="language-plaintext highlighter-rouge">template &lt;unsigned int N&gt;</code>.</p>

<p>Now we will create a struct which holds the obfuscated string (which 
will replace the plaintext in the source code) and has a compile time 
function (<code class="language-plaintext highlighter-rouge">constexpr</code>) as a constructor to obfuscate the plaintext:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Obfuscator</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="n">constexpr</span> <span class="n">Obfuscator</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">plaintext</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">plaintext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="mh">0x00</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now we obfuscate data in source code by creating an <code class="language-plaintext highlighter-rouge">Obfuscator&lt;7&gt;</code> struct from the <code class="language-plaintext highlighter-rouge">Obfuscator&lt;N&gt;</code> template (7 = string length + null byte):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">constexpr</span> <span class="n">Obfuscator</span><span class="o">&lt;</span><span class="mi">7</span><span class="o">&gt;</span> <span class="n">obfuscated</span> <span class="o">=</span> <span class="n">Obfuscator</span><span class="o">&lt;</span><span class="mi">7</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"secret"</span><span class="p">);</span>
</code></pre></div></div>

<p>To actually use the data in the application we need to decrypt it, so
 we add deobfuscation function (which operates on a constant value, 
hence the <code class="language-plaintext highlighter-rouge">const</code> identifier following its declaration) to the <code class="language-plaintext highlighter-rouge">Obfuscator</code> template:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">Deobfuscate</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">plaintext</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">plaintext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="mh">0x11</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">plaintext</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now we can deobfuscate the <code class="language-plaintext highlighter-rouge">obfuscated</code> constant variable: <code class="language-plaintext highlighter-rouge">obfuscated.Deobfuscate()</code>.</p>

<p>The last thing to do is to create a helper macro which simplifies the
 obfuscation in the source code. We will use another goodie of <code class="language-plaintext highlighter-rouge">C++11</code> - lambda functions:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define Obfuscated(string) []() -&gt; const char* \
{ \
	constexpr auto secret = Obfuscator&lt;sizeof(string) / sizeof(string[0])&gt;(string); \
	return secret.Deobfuscate(); \
}()
</span></code></pre></div></div>

<p>Thanks to this string literals appearing in the binary are XOR 
encrypted. It’s possible to enhance this method to make the application 
create stack based strings which won’t appear in the <code class="language-plaintext highlighter-rouge">.text</code> section of PE file.</p>

<h3 id="other-possibilities">Other possibilities</h3>
<p>It’s possible to implement quite advanced string and code obfuscation
 using template metaprogramming. For more detailed explanation see <a href="https://www.blackhat.com/docs/eu-14/materials/eu-14-Andrivet-C-plus-plus11-Metaprogramming-Applied-To-software-Obfuscation-wp.pdf">this awesome workpaper</a> by Sebastien Andrivet and his <a href="https://github.com/andrivet/ADVobfuscator">ADVobfuscator tool</a>
 which implements described concepts. There is a number of such 
obfuscators available and the best thing about them is that we can use 
them by just adding header files to the project:</p>

<p><a href="https://github.com/fritzone/obfy">https://github.com/fritzone/obfy</a></p>

<p><a href="https://github.com/revsic/cpp-obfuscator">https://github.com/revsic/cpp-obfuscator</a></p>

<h2 id="summary">Summary</h2>
<p>This post was just an introduction to advanced and powerful 
obfuscation methods which leverage LLVM compiler infrastructure and 
template metaprogramming.</p>

<p>Next time we will talk about keyloggers and implement one.</p>

  </div>

  <div class="date">
    Written on January 25, 2021
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/0xPat"><i class="svg-icon github"></i></a>

<a href="https://www.linkedin.com/in/patryk-czeczko"><i class="svg-icon linkedin"></i></a>


<a href="https://www.twitter.com/0xPat"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    

  

</body></html>